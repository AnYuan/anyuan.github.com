<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Anyuan&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="Anyuan's blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Anyuan's blog">
<meta property="og:description" content="记录点滴">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Anyuan's blog">
<meta name="twitter:description" content="记录点滴">
  
    <link rel="alternative" href="/atom.xml" title="Anyuan&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Anyuan&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">home</a>
        
          <a class="main-nav-link" href="/archives">archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS-7-9-新特性总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/13/iOS-7-9-新特性总结/" class="article-date">
  <time datetime="2015-09-13T08:29:53.000Z" itemprop="datePublished">2015-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/13/iOS-7-9-新特性总结/">iOS 7 - 9 新特性总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="iOS_7">iOS 7</h3><ol>
<li><p><a href="https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009542" target="_blank" rel="external">Text Kit</a></p>
<p> 文字排版相关</p>
</li>
</ol>
<ol>
<li>多任务<ul>
<li>设置<code>UIBackgroundModes</code>为<code>fetch</code>来进行定期后台下载。</li>
<li>设置<code>UIBackgroundModes</code>为<code>remote-notification</code>, 用远程推送的方式，来让应用在后台进行下载内容。</li>
</ul>
</li>
</ol>
<ol>
<li>NSURLSession 用来替代NSURLConnection，配合多任务后台下载使用。</li>
<li><p>AirDrop<br> 附近设备分享传输文件，不需要网络。</p>
</li>
<li><p>新Framework:</p>
<ul>
<li>GameController.framework - 与游戏硬件通信</li>
<li>SpriteKit.framework - 游戏图形渲染和动画</li>
<li>Multipeer connectivity framework - 点对点网络</li>
<li>JavaScriptCore.framework - JavaScript对象的oc封装</li>
<li>MediaAccessibility.framework</li>
<li>SafariServices.framework - 用程序添加URL到用户Safari的阅读列表等</li>
</ul>
</li>
</ol>
<h3 id="iOS_8">iOS 8</h3><ol>
<li><p>Swift 1.0</p>
</li>
<li><p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214" target="_blank" rel="external">App Extension</a></p>
<ul>
<li>Share， 在系统提供的分享选项中添加自己</li>
<li>Action, 对于选中内容可以执行一个action</li>
<li>Today， 通知中心的widget</li>
<li>Photo editinig.</li>
<li>Storage provider. 与其他应用共享文件存储位置</li>
<li>自定义键盘</li>
</ul>
</li>
<li><p><a href="https://developer.apple.com/library/ios/samplecode/KeychainTouchID/Introduction/Intro.html#//apple_ref/doc/uid/TP40014530" target="_blank" rel="external">Touch ID</a></p>
</li>
<li><p>Photos Framework</p>
</li>
<li>AV Audio Engine: Core Audio 更上层的封装。</li>
<li>HealthKit Framework</li>
<li>HomeKit Framework</li>
<li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/Handoff/HandoffFundamentals/HandoffFundamentals.html#//apple_ref/doc/uid/TP40014338" target="_blank" rel="external">Handoff</a></li>
<li>Size class</li>
<li>Metal - 替代OpenGL ES</li>
</ol>
<h3 id="iOS_9">iOS 9</h3><ol>
<li>Swift 2.0: 错误处理，Availability, Protocol extensions等</li>
<li>iPad 多任务</li>
<li>watchOS2</li>
<li>UI Test</li>
<li>App Thinning</li>
<li>Search API可以搜索App内容</li>
<li>新系统字体San francisco</li>
<li>Safari View Controller</li>
<li>Contacts Framework</li>
<li>3D Touch</li>
<li>Live Photo</li>
</ol>
<p>参考资料：<br>1.<a href="https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS7.html" target="_blank" rel="external">https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS7.html</a></p>
<p>2.<a href="https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS8.html#//apple_ref/doc/uid/TP40014205-SW1" target="_blank" rel="external">https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS8.html#//apple_ref/doc/uid/TP40014205-SW1</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/09/13/iOS-7-9-新特性总结/" data-id="cl4cdptrz001gjsv947egptls" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SQLite-WAL-调研总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/08/SQLite-WAL-调研总结/" class="article-date">
  <time datetime="2015-08-08T08:28:53.000Z" itemprop="datePublished">2015-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/08/SQLite-WAL-调研总结/">SQLite WAL 调研总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>iOS 系统从iOS 7版本自带的SQLite数据库<strong>默认</strong>为开启WAL模式，即<code>journal_mode=WAL</code></li>
<li>iOS 版本4.3 以上系统自带SQLite版本为3.7.0以上（SQLite 3.7.0开始支持WAL）</li>
<li>在创建数据库连接时，执行<br><code>[conn executeUpdate:[NSString stringWithFormat:@”PRAGMA journal_mode=WAL”]];<br></code>即可</li>
<li>使用注意，在开启数据库时，不能只读打开。</li>
<li>低版本的SQLite不能读取高版本的SQLite生成的WAL文件，但是数据库文件是通用的。这种情况在用户进行iOS降级时可能会出现，可以把模式改成delete，再改回WAL来修复。</li>
<li>iOS 版本的SQLite是线程安全的（db 连接不要多线程共享）。<a href="http://www.sqlite.org/cvstrac/wiki?p=MultiThreading" target="_blank" rel="external">详情</a></li>
</ul>
<h3 id="WAL_工作原理：">WAL 工作原理：</h3><p>开启WAL模式后， 会有3个文件:</p>
<p>{<1>}<img src="/Users/mac/Downloads/wal.png" alt="database"></1></p>
<p>.db 为数据库文件</p><br><p>-shm 为每个数据库文件的共享内存文件</p><br><p>-wal 对数据库的修改操作于此文件</p>

<p>修改并不直接写入到数据库文件中，而是写入到另外一个称为WAL的文件中；如果事务失败，WAL中的记录会被忽略，撤销修改；如果事务成功，它将在随后的某个时间被写回到数据库文件中，提交修改。</p>
<p>同步WAL文件和数据库文件的行为被称为checkpoint（检查点），它由SQLite自动执行，默认是在WAL文件积累到1000页修改的时候；当然，在适当的时候，也可以手动执行checkpoint，SQLite提供了相关的接口。执行checkpoint之后，WAL文件会被清空。</p>
<p>在读的时候，SQLite将在WAL文件中搜索，找到最后一个写入点（end mark），记住它，并忽略在此之后的写入点（<strong>这保证了读写和读读可以并行执行</strong>）；随后，它确定所要读的数据所在页是否在WAL文件中，如果在，则读WAL文件中的数据，如果不在，则直接读数据库文件中的数据。为了避免每次读操作都遍历整个WAL文件去查找，SQLite使用了一种叫做wal-index的数据结构（保存于-shm）用于提高查找效率同时减少磁盘I/O。</p>
<p>在写的时候，SQLite将之写入到WAL文件尾即可，读写互不影响，所以渡河写可以同时执行。因为只有一个WAL文件，所以必须保证一次只执行一次写操作，<strong>因此写操作之间不能并行执行</strong>。</p>
<p>checkpoint的时候，将WAL中的数据同步回数据库中。checkpoint操作可以与读操作并行，但，如果有读操作正在读checkpoint要更新的数据库中的数据时，checkpoint操作会停止，直到读操作完成。</p>
<p>WAL在实现的过程中，使用了共享内存技术，因此，所有的读写进程必须在同一个机器上，否则，无法保证数据一致性。</p>
<h3 id="WAL相关使用配置:">WAL相关使用配置:</h3><p>启动： <code>PRAGMA journal_mode=WAL;</code></p>
<h4 id="自动checkpoint操作：">自动checkpoint操作：</h4><p>默认情况下，SQLite 自动触发checkpoint操作</p>
<ul>
<li>当一个COMMIT时，WAL文件的page数超过1000（可配置）</li>
<li>database连接关闭时。</li>
</ul>
<h4 id="手动触发checkpoint操作：详情">手动触发checkpoint操作：<a href="https://www.SQLite.org/pragma.html#pragma_wal_checkpoint" target="_blank" rel="external">详情</a></h4><ul>
<li>PRAGMA wal_autocheckpoint;</li>
<li>PRAGMA wal_autocheckpoint=N;</li>
<li>SQLite3_wal_checkpoint()</li>
</ul>
<p><a href="https://www.sqlite.org/wal.html" target="_blank" rel="external">参考资料</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/08/08/SQLite-WAL-调研总结/" data-id="cl4cdptsb0020jsv9zu25jnh8" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQLite/">SQLite</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-NSAutoreleasePool-实现原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/10/NSAutoreleasePool-实现原理/" class="article-date">
  <time datetime="2014-12-10T08:16:30.000Z" itemprop="datePublished">2014-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/10/NSAutoreleasePool-实现原理/">NSAutoreleasePool 实现原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述">概述</h3><p>autorelease 是NSObject的一个类方法，它是通过调用<code>[NSAutoreleasePool addObject:self]</code> 来把一个对象添加到自动释放池中的，因为这是一个类方法，所以有必要知道是对哪个对象进行autorelease调用。</p>
<p>NSAutoreleasePool 实例是保存在每一个线程的stack中。当一个新pool创建，它就会进栈。当一个stack被销毁的时候，它就出栈。 使用NSAutoreleasePool类方法时，需要从当前线程中获取stack最上面的pool对象，来获取当前pool。</p>
<p>当找到正确的pool后，调用addObject: 实例方法来将对象添加到pool中。当对象被添加到pool中，其实他是添加到pool中的一个可变数组中去。</p>
<p>当pool被销毁时，pool会遍历可变数组中的所有对象，并发送 release 方法给每一个对象。还有一点额外说明，如果一个pool被销毁，并且这个pool不是stack最上端的，这个pool还会销毁该pool之上的所有pool。</p>
<h3 id="总结">总结</h3><p>没有方法知道一个对象是否已经被自动释放了。<br>如果对象被autorelease 两次，这个对象就会被两次添加到pool中，当pool被销毁，该对象就会被release两次。<br>自动释放池的对象是当当前自动释放池被释放时被释放。pool是当它的代码显性的销毁它时而被销毁。<br>如果在一个线程上autorelease一个对象，并将它传给另一个线程，不会有特殊处理。当第一个线程池被销毁的时候，该对象也会被release， 不管该对象在新线程发生了什么。如果你需要继续保留这个对象，就需要在传递之前retain这个对象。</p>
<p>原文链接：<a href="http://www.mikeash.com/pyblog/friday-qa-2911-09-02-lets-build-nsautoreleasepool.html" target="_blank" rel="external">http://www.mikeash.com/pyblog/friday-qa-2911-09-02-lets-build-nsautoreleasepool.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/12/10/NSAutoreleasePool-实现原理/" data-id="cl4cdptsl002djsv9doxtaqli" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Best-Practices-for-Handling-Multitouch-Events" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/01/Best-Practices-for-Handling-Multitouch-Events/" class="article-date">
  <time datetime="2014-12-01T08:27:32.000Z" itemprop="datePublished">2014-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/01/Best-Practices-for-Handling-Multitouch-Events/">Best Practices for Handling Multitouch Events</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>Always implement the event cancelation methods.</p>
  <p>In your implementation, restore the state of a view to what it was before the current multitouch sequence. If you don’t, your view could be left in an inconsistent state, or in some cases, another view could receive the cancelation message.</p>
</li>
<li><p>If you handle events in a subclass of UIView, UIViewController, or UIResponder:</p>
<ul>
<li>Implement all of the event handling methods, even if your implementations of those methods do nothing.</li>
<li>Do not call the superclass implementation of the methods.</li>
</ul>
<p></p></li>
<li><p>If you handle events in a subclass of any other UIKit responder class:</p>
<ul>
<li>You do not have to implement all of the event handling methods.</li>
<li>In the methods you do implement, be sure to call the superclass implementation. For example, <code>[super touchesBegan:touches withEvent:event]</code>.</li>
</ul>
<p></p>
</li>
<li><p>Do not forward events to other responder objects of the UIKit Framework.</p>
<p>Instead, forward events to instances of your own subclasses of UIView. Additionally, make sure these responder objects are aware that event forwarding is taking place and tat they can receive touches that are not bound to them.</p>
</li>
<li><p>Do not explicitly send events up the responder chain through the nextResponder method; instead, invoke the superclass implementation and let UIKit handle responder-chain traversal.</p>
</li>
<li><p>Do not use round-to-integer code in your touch handling because you lose precision.</p>
<p>iOS reports touches in a 320x480 coordinate space to maintain source compatiblity. However, on high-resolution devices, the resolution is actually twice as high in each dimension(640x960), which means that touches can land on half-point boundaries on high-resolution devices. On older devices, touches land only on full-point boundaries.</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/12/01/Best-Practices-for-Handling-Multitouch-Events/" data-id="cl4cdptpq0000jsv9vvpujex7" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-企业证书签名包ipa无线安装服务器搭建注意事项" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/26/iOS-企业证书签名包ipa无线安装服务器搭建注意事项/" class="article-date">
  <time datetime="2014-08-26T08:26:34.000Z" itemprop="datePublished">2014-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/26/iOS-企业证书签名包ipa无线安装服务器搭建注意事项/">iOS 企业证书签名包ipa无线安装服务器搭建注意事项</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>因为iOS 7.1以后要求链接地址为https(itms-services://?action=download-manifest&amp;url=<a href="https://10.208.99.199/ota/ios/plist/8239)，所以apache服务器要开启https，具体步骤参见：http://www.cnblogs.com/y500/p/3596473.html" target="_blank" rel="external">https://10.208.99.199/ota/ios/plist/8239)，所以apache服务器要开启https，具体步骤参见：http://www.cnblogs.com/y500/p/3596473.html</a></li>
</ol>
<p>在以上步骤需要注意的是，生成SSL证书时，输入的common name要以服务器地址名称一致，如10.208.99.199或者域名，或者</p>
<pre><code>10.<span class="keyword">*</span>.<span class="keyword">*</span>.<span class="keyword">*</span>
</code></pre><p> 通配符形式。</p>
<ol>
<li><p>apache配置文件httpd.conf, httpd-ssl.conf, httpd-vhost.conf三个文件中的ServerName 都要配成与证书适配的名称，如10.208.99.199， 此处一定要保持一致。</p>
</li>
<li><p>在apache httpd.conf配置文件中添加</p>
<pre><code><span class="keyword">AddType </span>application/octet-<span class="keyword">stream </span>ipa
</code></pre></li>
</ol>
<p>, 是为Mac OS X上的配置，其他请上网查阅一下。</p>
<ol>
<li><p>启动apache服务器</p>
<pre><code>sudo apachectl -<span class="keyword">D</span> SSL -k restart
</code></pre></li>
</ol>
<p>通过以上配置，应该是可以搭建无线安装ipa的服务器了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/26/iOS-企业证书签名包ipa无线安装服务器搭建注意事项/" data-id="cl4cdptrk000ujsv96uesj5ae" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-Web-py网站迁移Mac-OS-X" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/23/Linux-Web-py网站迁移Mac-OS-X/" class="article-date">
  <time datetime="2014-08-23T08:25:35.000Z" itemprop="datePublished">2014-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/23/Linux-Web-py网站迁移Mac-OS-X/">Linux Web.py网站迁移Mac OS X</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>数据库导出</p>
<pre><code>mysqldump --opt -u name -<span class="tag">p</span> dbname &gt; backupfile.sql
</code></pre></li>
<li><p>在Mac OS X上安装web.py环境<br>0）install web.py</p>
<pre><code>sudo pip <span class="keyword">install</span> web.py
</code></pre></li>
</ol>
<p>1) 安装mod_wsgi<br>下载mod_wsgi</p>
<p><a href="http://code.google.com/p/modwsgi/wiki/DownloadTheSoftware?tm=2" target="_blank" rel="external">http://code.google.com/p/modwsgi/wiki/DownloadTheSoftware?tm=2</a></p>
<p>解压，</p>
<pre><code>./configure

<span class="built_in">make</span>

sudo <span class="built_in">make</span> install
</code></pre><p>2) 配置apache httpd.conf</p>
<pre><code>#<span class="operator"><span class="keyword">Load</span> mod_wsgi <span class="keyword">module</span>:
LoadModule wsgi_module libexec/apache2/mod_wsgi.so

WSGIScriptAlias /ota /<span class="keyword">Users</span>/iosteam/ota_all/website.py/

AddType <span class="built_in">text</span>/html .py

<span class="keyword">Alias</span> /ota/<span class="keyword">static</span> <span class="string">"/Users/iosteam/ota_all/static"</span>

&lt;<span class="keyword">Directory</span> <span class="string">"/Users/iosteam/ota_all"</span>&gt;

  <span class="keyword">Order</span> deny,<span class="keyword">allow</span>

  <span class="keyword">Allow</span> <span class="keyword">from</span> all

&lt;/<span class="keyword">Directory</span>&gt;</span>
</code></pre><p>3) 如果仍不能访问，修改对应的webpy启动文件</p>
<pre><code><span class="comment"># for mod_python</span>

app = web.<span class="type">application</span>(urls, globals())

<span class="type">application</span> = app.wsgifunc()
</code></pre><ol>
<li><p>导入数据库数据</p>
<pre><code>mysql -u root -<span class="tag">p</span> &lt; database.sql
</code></pre></li>
<li><p>安装python连接数据库包</p>
<pre><code>sudo pip search MySQL_python
sudo pip <span class="keyword">install</span> MySQL_python
</code></pre></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/23/Linux-Web-py网站迁移Mac-OS-X/" data-id="cl4cdptsq002hjsv9z13vc98y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-服务器高I-O-等待延迟问题查找" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/17/Linux-服务器高I-O-等待延迟问题查找/" class="article-date">
  <time datetime="2014-08-17T08:24:51.000Z" itemprop="datePublished">2014-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/17/Linux-服务器高I-O-等待延迟问题查找/">Linux 服务器高I/O 等待延迟问题查找</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>首先是top查看一下系统状况</li>
</ol>
<p>发现两个参数异常，一是平均负载高，一是cpu %wa一直在50%以上。</p>
<p>查了一下%wa参数的意义：</p>
<pre><code>wa <span class="comment">-- iowait</span>
 Amount <span class="operator">of</span> <span class="built_in">time</span> <span class="operator">the</span> CPU has been waiting <span class="keyword">for</span> I/O <span class="built_in">to</span> complete.
</code></pre><ol>
<li>查看磁盘读写数据</li>
</ol>
<p>用iostat 查看磁盘状况</p>
<pre><code>$ iostat -x <span class="number">2</span> <span class="number">5</span>
 avg-cpu: %user %nice %system %iowait %steal %idle
  <span class="number">3.66</span> <span class="number">0.00</span> <span class="number">47.64</span> <span class="number">48.69</span> <span class="number">0.00</span> <span class="number">0.00</span>

 Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util
 sda <span class="number">44.50</span> <span class="number">39.27</span> <span class="number">117.28</span> <span class="number">29.32</span> <span class="number">11220.94</span> <span class="number">13126.70</span> <span class="number">332.17</span> <span class="number">65.77</span> <span class="number">462.79</span> <span class="number">9.80</span> <span class="number">2274.71</span> <span class="number">7.60</span> <span class="number">111.41</span>
 dm-<span class="number">0</span> <span class="number">0.00</span> <span class="number">0.00</span> <span class="number">83.25</span> <span class="number">9.95</span> <span class="number">10515.18</span> <span class="number">4295.29</span> <span class="number">317.84</span> <span class="number">57.01</span> <span class="number">648.54</span> <span class="number">16.73</span> <span class="number">5935.79</span> <span class="number">11.48</span> <span class="number">107.02</span>
 dm-<span class="number">1</span> <span class="number">0.00</span> <span class="number">0.00</span> <span class="number">57.07</span> <span class="number">40.84</span> <span class="number">228.27</span> <span class="number">163.35</span> <span class="number">8.00</span> <span class="number">93.84</span> <span class="number">979.61</span> <span class="number">13.94</span> <span class="number">2329.08</span> <span class="number">10.93</span> <span class="number">107.02</span>
</code></pre><p>2.查看进程状态<br>进程状态表</p>
<pre><code>PROCESS STATE CODES
 D uninterruptible sleep (usually IO)
 R <span class="property">running</span> <span class="keyword">or</span> runnable (<span class="function_start"><span class="keyword">on</span></span> <span class="command">run</span> queue)
 S interruptible sleep (waiting <span class="keyword">for</span> an event <span class="keyword">to</span> complete)
 T stopped, either <span class="keyword">by</span> a job control signal <span class="keyword">or</span> because <span class="keyword">it</span> <span class="keyword">is</span> being traced.
 W paging (<span class="keyword">not</span> valid <span class="keyword">since</span> <span class="keyword">the</span> <span class="number">2.6</span>.xx kernel)
 X dead (should never be seen)
 Z defunct (<span class="string">"zombie"</span>) process, terminated <span class="keyword">but</span> <span class="keyword">not</span> reaped <span class="keyword">by</span> <span class="keyword">its</span> parent.
</code></pre><p>查看到进程中状态D（disk sleep）的进程</p>
<pre><code># <span class="keyword">for</span> <span class="keyword">x</span> in `seq <span class="number">1</span> <span class="number">1</span> <span class="number">10</span>`; <span class="keyword">do</span> <span class="keyword">ps</span> -eo state,pid,cmd | <span class="keyword">grep</span> <span class="string">"^D"</span>; <span class="keyword">echo</span> <span class="string">"----"</span>; <span class="keyword">sleep</span> <span class="number">5</span>; done
</code></pre><p>查看到有kjournald这个进程<br>查看这个进程是做什么的？</p>
<p>kjournald是ext3文件系统记录文件系统日志的进程。</p>
<p>查看进程相关状态信息</p>
<pre><code><span class="preprocessor"># cat /proc/<span class="number">487</span>/io</span>
 rchar: <span class="number">48752567</span>
 wchar: <span class="number">549961789</span>
 syscr: <span class="number">5967</span>
 syscw: <span class="number">67138</span>
 read_bytes: <span class="number">49020928</span>
 write_bytes: <span class="number">549961728</span>
 cancelled_write_bytes: <span class="number">0</span>
</code></pre><p>查看都往哪写东西了</p>
<pre><code><span class="preprocessor"># lsof -p <span class="number">487</span></span>
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/17/Linux-服务器高I-O-等待延迟问题查找/" data-id="cl4cdptsm002fjsv9fmbak1z9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-GCD常用函数总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/04/19/iOS-GCD常用函数总结/" class="article-date">
  <time datetime="2014-04-19T07:58:16.000Z" itemprop="datePublished">2014-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/19/iOS-GCD常用函数总结/">iOS GCD常用函数总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>GCD提供两种Dispatch Queue, 分别为Concurrent Dispatch Queue 和 Serial Dispatch Queue.</p>
<p>Serial Dispatch Queue 使用一个thread。</p>
<p>Concurrent Dispatch Queue 使用多个thread。</p>
<p>获取Dispatch Queue:</p>
<p>0）dispatch_queue_create</p>
<pre><code><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"name.of.your.queue"</span>,<span class="literal">NULL</span>);
</code></pre><p>第一个参数为queue的名字，第二个参数传NULL表明要创建一个Serial Dispatch Queue, 传入DISPATCH_QUEUE_CONCURRENT 创建一个 Concurrent Dispatch Queue。<br>如果是对数据库表更新或更新文件，最好为每一个表或文件建立一个Serial Dispatch Queue，这样能保证只有一个thread会对数据进行更新。</p>
<p>如果对那些不会引起数据不一致问题的任务，需要放到Concurrent Dispatch Queue执行。</p>
<p>1）从Main Dispatch Queue/Global Dispatch Queue获取</p>
<pre><code><span class="comment">//main queue</span>
<span class="keyword">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();

<span class="comment">//global queue of high priority</span>
<span class="keyword">dispatch_queue_t</span> globalHigh =         dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,<span class="number">0</span>);

<span class="comment">//global queue of default priority</span>
<span class="keyword">dispatch_queue_t</span> globalDefault =     dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);

<span class="comment">//global queue of low priority</span>
<span class="keyword">dispatch_queue_t</span> globalLow = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW,<span class="number">0</span>);

<span class="comment">//global queue of background priority</span>
<span class="keyword">dispatch_queue_t</span> globalBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,<span class="number">0</span>);
</code></pre><p>Main Dispatch Queue -&gt; Serial dispatch queue<br>Global Dispatch Queue -&gt; Concurrent dispatch queue</p>
<p>dispatch_set_target_queue: 主要用来给新建的queue设置优先级</p>
<pre><code>dispatch_queue_t serialQueue = dispatch_queue_create<span class="list">(<span class="string">"name.of.queue"</span>,NULL)</span><span class="comment">;</span>

dispatch_queue_t globalQueue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_BACKGROUND</span>,<span class="number">0</span>)</span><span class="comment">;</span>

dispatch_set_target_queue<span class="list">(<span class="keyword">serialQueue</span>, globalQueue)</span><span class="comment">;</span>
</code></pre><p>需要注意的是，第一个参数是自定义的queue，而不是系统的queue。因为你不能给系统的queue设置权限。通过上面设置，serialQueue 就有了与globalQueue一样的优先级。其实这个函数不仅可以设置queue的优先级，还可以设置queue之间的层级结构。</p>
<p>dispatch_after: 过一段时间执行queue中的task</p>
<pre><code>dispatch_time_t <span class="property">time</span> = dispatch_time(DISPATCH_TIME_NOW, <span class="number">3</span>ull * NSEC_PER_SEC);

dispatch_after(<span class="property">time</span>, dispatch_get_main_queue(),^{
           NSLog(@<span class="string">"after 3 seconds..."</span>);});
</code></pre><p>Dispatch Group</p>
<p>0）dispatch_group_notify</p>
<p>dispatch group 可以在group中的dispatch queue都执行完之后，通过一个dispatch_group_notify通知回调。</p>
<pre><code>dispatch_queue_t queue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>,<span class="number">0</span>)</span><span class="comment">;</span>

dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span>

dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^{NSLog<span class="list">(@<span class="string">"task1"</span>)</span><span class="comment">;});</span>
dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^{NSLog<span class="list">(@<span class="string">"task2"</span>)</span><span class="comment">;});</span>
dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^{NSLog<span class="list">(@<span class="string">"task3"</span>)</span><span class="comment">;});</span>

dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^{NSLog<span class="list">(@<span class="string">"finished..."</span>)</span><span class="comment">;});</span></span></span></span></span>
</code></pre><p>输出总会保证”finished…”会在最后一句输出。</p>
<pre><code><span class="number">1</span>）dispatch_group_wait

dispatch_queue_t <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);

dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();

dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{NSLog(@<span class="string">"task1"</span>);});
dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{NSLog(@<span class="string">"task2"</span>);});
dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{NSLog(@<span class="string">"task3"</span>);});

dispatch_group_wait(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER);
</code></pre><p>dispatch_group_wait提供了一种类似超时的机制，当然如果等待时间设置为DISPATCH_TIME_FOREVER,功能和dispatch_group_notify是一样的。</p>
<p>dispatch_barrier_async</p>
<p>dispatch_barrier_async是一个可以让当前任务等待queue其他任务完成再执行的函数。例如，从数据库读取数据是可以多线程并发读取的，因为这样提高效率。但是，更新数据库数据，就要保证只有一个线程进行更新操作。所以，当更新操作发生的时候，一定要保证读操作和其他更新操作等待。</p>
<pre><code>dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"barrier.queue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span>

dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_0)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_1)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_2)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_3)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_4)</span><span class="comment">;</span>

dispatch_barrier_async<span class="list">(<span class="keyword">queue</span>, update_block)</span><span class="comment">;</span>

dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_5)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_6)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_7)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_8)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_9)</span><span class="comment">;</span>
</code></pre><p>这样就可以保证只有当更新操作结束后，才会进行其他数据库读操作，保证了数据的一致性。</p>
<p>dispatch_apply</p>
<p>dispatch_apply用于给一个block添加到dispatch queue若干次。 “for”循环</p>
<pre><code><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);

dispatch_apply(<span class="number">10</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> index) { NSLog(@<span class="string">"%zu"</span>,index);});

NSLog(@<span class="string">"done..."</span>);
</code></pre><p>dispatch_suspend/dispatch_resume</p>
<p>用于暂停和继续执行queue</p>
<p>dispatch semaphore</p>
<p>dispatch semaphore 适合处理比dispatch queue或者dispatch_barrier_async更小颗粒度的操作。</p>
<p>例如，</p>
<pre><code><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);

NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];

<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)
{
dispatch_async(<span class="built_in">queue</span>, ^{
  [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:i]];
});
}
</code></pre><p>如果执行上段代码，因为NSMutableArray不是thread safe的，所以在global queue中对其进行添加对象，会导致程序crash掉。</p>
<p>使用dispatch semaphore我们可以实现多线程对NSMutableArray进行操作</p>
<pre><code><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);

<span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>);

NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];

<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)
{
dispatch_async(<span class="built_in">queue</span>, ^{

  dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);

  [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:i]];

  dispatch_semaphore_signal(semaphore);
});
}
</code></pre><p>dispatch semaphore 是一个信号量的counter，当counter为0，当前线程停止运行，当大于0，自减1，继续执行。</p>
<p>dispatch_semaphore_create</p>
<pre><code><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>);
</code></pre><p>初始化一个counter为1的semaphore.<br>dispatch_semaphore_wait</p>
<pre><code>dispatch_semaphore_wait<span class="list">(<span class="keyword">semaphore</span>, DISPATCH_TIME_FOREVER)</span><span class="comment">;</span>
</code></pre><p>等待counter大于0才运行，第二个参数为等待时间。执行后counter减1.</p>
<p>dispatch_semaphore_signal</p>
<pre><code>dispatch_semaphore_signal<span class="list">(<span class="keyword">semaphore</span>)</span><span class="comment">;</span>
</code></pre><p>给counter加1<br>所以在上面的代码中，就可以保证在wait和signal中的[array addObject:[NSNumber numberWithInt:i]]; 就只有一个thread进行操作，保证了线程安全。</p>
<p>dispatch_onece</p>
<p>保证了dispatch_once中的代码只会被执行一次，常用于单例。</p>
<pre><code>+ (<span class="keyword">id</span>)sharedManager {
<span class="keyword">static</span> MyManager *sharedMyManager = <span class="literal">nil</span>;
<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
<span class="built_in">dispatch_once</span>(&amp;onceToken, ^{
    sharedMyManager = [[<span class="keyword">self</span> alloc] init];
});
<span class="keyword">return</span> sharedMyManager;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/04/19/iOS-GCD常用函数总结/" data-id="cl4cdptrw0018jsv9ft1xxnxp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-Block实现探究" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/04/06/iOS-Block实现探究/" class="article-date">
  <time datetime="2014-04-06T08:22:21.000Z" itemprop="datePublished">2014-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/06/iOS-Block实现探究/">iOS Block实现探究</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用clang的rewrite-objc filename 可以将有block的c代码转换成cpp代码。从中可以看到block的实现。</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
  <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^{
    <span class="built_in">printf</span>(<span class="string">"Block\n"</span>);
  };
  blk();
  <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>使用clang rewrite-objc以后会看到block的实现</p>
<pre><code><span class="keyword">struct</span> __main_block_impl_0 {
 <span class="keyword">struct</span> __block_impl <span class="keyword">impl</span>;
 <span class="keyword">struct</span> __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>)
{
<span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;
<span class="keyword">impl</span>.Flags = flags;
<span class="keyword">impl</span>.FuncPtr = fp;
Desc = desc;
 }
};
</code></pre><p>可以看到其实block是一个正常的OC类</p>
<p>来看看block是怎样访问外部变量的</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
  <span class="keyword">int</span> dmy = <span class="number">256</span>;
  <span class="keyword">int</span> val = <span class="number">10</span>;
  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"val = %d\n"</span>;
  <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^{
    <span class="built_in">printf</span>(fmt, val);
  };
  <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>转换之后，可以看到</p>
<pre><code><span class="keyword">struct</span> __main_block_impl_0 {
  <span class="keyword">struct</span> __block_impl impl;
  <span class="keyword">struct</span> __main_block_desc_0* Desc;
  <span class="keyword">const</span> <span class="keyword">char</span> *fmt;
  <span class="keyword">int</span> val;
  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">const</span> <span class="keyword">char</span> *_fmt, <span class="keyword">int</span> _val, <span class="keyword">int</span> flags=<span class="number">0</span>) : fmt(_fmt), val(_val) {
impl.isa = &amp;_NSConcreteStackBlock;
impl.Flags = flags;
impl.FuncPtr = fp;
Desc = desc;
  }
};


<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
  <span class="keyword">int</span> dmy = <span class="number">256</span>;
  <span class="keyword">int</span> val = <span class="number">10</span>;
  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"val = %d\n"</span>;
  <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val);
  <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>block的变量会被复制进block中</p>
<p>如果当block要改变传入的变量值怎么办？首先看一下全局变量和本地静态变量</p>
<pre><code><span class="keyword">int</span> global_val = <span class="number">1</span>;
<span class="keyword">static</span> <span class="keyword">int</span> static_global_val = <span class="number">2</span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
  <span class="keyword">static</span> <span class="keyword">int</span> static_val = <span class="number">3</span>;
  <span class="keyword">void</span>(^blk)(<span class="keyword">void</span>) = ^{
  global_val *= <span class="number">1</span>;
   static_global_val *= <span class="number">2</span>;
  static_val *= <span class="number">3</span>;
  };
  blk();
  <span class="keyword">return</span> <span class="number">0</span>;
}



<span class="keyword">struct</span> __main_block_impl_0 {
  <span class="keyword">struct</span> __block_impl impl;
  <span class="keyword">struct</span> __main_block_desc_0* Desc;
  <span class="keyword">int</span> *static_val;
  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> *_static_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : static_val(_static_val) {
impl.isa = &amp;_NSConcreteStackBlock;
impl.Flags = flags;
impl.FuncPtr = fp;
Desc = desc;
  }
};
<span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) {
  <span class="keyword">int</span> *static_val = __cself-&gt;static_val; <span class="comment">// bound by copy</span>

global_val *= <span class="number">1</span>;
static_global_val *= <span class="number">2</span>;
(*static_val) *= <span class="number">3</span>;
}
</code></pre><p>由于全局变量是在Data Section中，所以直接可以访问。局部静态变量是通过将其指针传入到block中，block就可以对其值进行修改。</p>
<p>然后看一下__block修饰符变量</p>
<pre><code><span class="type">int</span> main()
{
  __block <span class="type">int</span> val = <span class="number">10</span>;
  <span class="type">void</span> (^blk)(<span class="type">void</span>) = ^{val = <span class="number">1</span>;};
  blk();
  <span class="keyword">return</span> <span class="number">0</span>;
}

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* <span class="type">Desc</span>;
  __Block_byref_val_0 *val; // by <span class="keyword">ref</span>
  __main_block_impl_0(<span class="type">void</span> *fp, struct __main_block_desc_0 *desc,             __Block_byref_val_0 *_val, <span class="type">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) {
impl.isa = &amp;_NSConcreteStackBlock;
impl.<span class="type">Flags</span> = flags;
impl.<span class="type">FuncPtr</span> = fp;
<span class="type">Desc</span> = desc;
  }
};
<span class="keyword">static</span> <span class="type">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_val_0 *val = __cself-&gt;val; // bound by <span class="keyword">ref</span>
(val-&gt;__forwarding-&gt;val) = <span class="number">1</span>;}
<span class="keyword">static</span> <span class="type">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src)
</code></pre><p><strong>block修饰符的变量，会生成一个</strong>Block_byref_val_0的struct，然后通过访问其<strong>forwarding来访问val值。因为Block有可能是在stack或者heap中，所以用</strong>forwarding来访问。之所以会将__block单独生成一个struct是因为可能该变量会被多个block使用。</p>
<p>Block分三种类型</p>
<p>0) NSConcreteStackBlock    –stack</p>
<p>1) NSConcreteGlobalBlock   –data area</p>
<p>2) NSConcreteMallocBlock   –heap</p>
<p>自动copy block</p>
<p>当开启ARC时，在某些情况编译器会自动copy block，从stack到heap。</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">int</span> （^<span class="keyword">blk_t</span>)(<span class="keyword">int</span>);
<span class="keyword">blk_t</span> func(<span class="keyword">int</span> rate)
{
  <span class="keyword">return</span> ^(<span class="keyword">int</span> count){<span class="keyword">return</span> rate * count;};
}


<span class="keyword">blk_t</span> func(<span class="keyword">int</span> rate)
{
  <span class="keyword">blk_t</span> tmp = &amp;__func_block_impl_0(
__func_block_func_0, &amp;__func_block_desc_0_DATA, rate);

  tmp = objc_retainBlock(tmp);
  <span class="keyword">return</span> objc_autoreleaseReturnValue(tmp);
}
</code></pre><p>有些情况，编译器是无法检测是否应该copy block：</p>
<p>当block作为参数传递到方法或函数中。</p>
<p>但是，如果该方法或函数在内部copy，就不用手动再copy：</p>
<p>0）cocoa framework方法， 有usingBlock</p>
<p>1) GCD API</p>
<pre><code>- (<span class="keyword">id</span>) getBlockArray
{
  <span class="keyword">int</span> val = <span class="number">10</span>;
  <span class="keyword">return</span> [[<span class="built_in">NSArray</span> alloc] initWithObjects:
 [^{<span class="built_in">NSLog</span>(<span class="string">@"blk0:%d"</span>, val);} <span class="keyword">copy</span>],
 [^{<span class="built_in">NSLog</span>(<span class="string">@"blk1:%d"</span>, val);} <span class="keyword">copy</span>], <span class="literal">nil</span>];
}
</code></pre><p>__forwarding</p>
<p>当block从stack copy到 heap中时，block中用到的<strong>block也会copy到heap中，并且copy到heap中的block拥有该</strong>block。</p>
<pre><code>__block int <span class="keyword">val</span> = <span class="number">0</span>;
<span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = [^{++<span class="keyword">val</span>;} copy];
++<span class="keyword">val</span>;
blk();
NSLog(<span class="string">@"%d"</span>, <span class="keyword">val</span>);
</code></pre><p>在block和外的++val都会变成 ++(val.<strong>forwarding-&gt;val);<br>当block copy到heap中后， stack中的</strong>forwarding会指向heap中的<strong>block, heap中的</strong>forwarding会指向自己的<strong>block值，这样保证了</strong>forwarding指向的是同一个变量值。</p>
<p>Block什么时候会copy到heap中</p>
<p>0）对block调用copy方法。</p>
<p>1）block作为一个函数的返回值。 编译器自动copy</p>
<p>2）赋值给id或block type class 有__strong 修饰符的成员变量。   编译器自动copy</p>
<p>3）usingBlock, GCD API。  在函数内copy</p>
<p>什么时候用该copy block？</p>
<p>0） block是函数返回值</p>
<p>1） block赋值给id或block type class 有__strong 修饰符的成员变量。</p>
<p>2）3）usingBlock, GCD API。  在函数内copy</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/04/06/iOS-Block实现探究/" data-id="cl4cdptry001ejsv96zot8q2n" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-UIApplicationDelegate-启动选项介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/03/05/UIApplicationDelegate-启动选项介绍/" class="article-date">
  <time datetime="2014-03-05T08:19:36.000Z" itemprop="datePublished">2014-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/03/05/UIApplicationDelegate-启动选项介绍/">UIApplicationDelegate 启动选项介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#10;&#123;&#10;  // Override point for customization after application launch.&#10;  return YES;&#10;&#125;&#10;&#10;- (void)applicationWillResignActive:(UIApplication *)application&#10;&#123;&#10;  // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.&#10;  // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.&#10;&#125;&#10;&#10;- (void)applicationDidEnterBackground:(UIApplication *)application&#10;&#123;&#10;  // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.&#10;  // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.&#10;&#125;&#10;&#10;- (void)applicationWillEnterForeground:(UIApplication *)application&#10;&#123;&#10;  // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.&#10;&#125;&#10;&#10;- (void)applicationDidBecomeActive:(UIApplication *)application&#10;&#123;&#10;  // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.&#10;&#125;&#10;&#10;- (void)applicationWillTerminate:(UIApplication *)application&#10;&#123;&#10;  // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>每个iOS app的入口都是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br></pre></td></tr></table></figure>
<p>当app启动完成，准备运行时，application会调用自己的这个代理方法。</p>
<p>一个app除了点击图标进行启动，还有一些其他方式调用一个app。区别不同启动方式，就需要用到launchOptions. 与userInfo 字典相似，<code>-application:didFinishLaunchingWithOptions:</code> 可以通过launchOptions获取启动信息的key。</p>
<p><strong>通过URL启动</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&#34;app://...&#34;]];</span><br></pre></td></tr></table></figure>
<p><a href="http://URL" target="_blank" rel="external">http://URL</a> 会调用Safari， mailto://URL 会打开邮箱， tel://URL 会拨打电话。</p>
<p>这种情况下<code>launchOptions</code> 为<code>UIApplicationLaunchOptionsURLKey</code></p>
<p>app通过URL调用时，还可以有一些系统信息。 当通过<code>UIDocumentInteractionController</code> 或者 AirDrop 调用时，<code>launchedOptions</code> 会被设置为：</p>
<p><code>UIApplicationLaunchOptionsSourceApplicationKey:</code> key值是一个NSString，表示要调用你app的app bundle ID</p>
<p><code>UIApplicationLaunchOptionsAnnotationKey:</code> key可以存储property-list 对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSURL *fileURL = [[NSBundle mainBundle] URLForResource:@&#34;Document&#34; withExtension:@&#34;pdf&#34;];&#10;if (fileURL) &#123;&#10;  UIDocumentInteractionController *documentInteractionController =&#10;  [UIDocumentInteractionController interactionControllerWithURL:fileURL];&#10;&#10;  documentInteractionController.annotation = @&#123;@&#34;foo&#34;: @&#34;bar&#34;&#125;;&#10;  [documentInteractionController setDelegate:self];&#10;  [documentInteractionController presentPreviewAnimated:YES];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>推送消息调用</strong></p>
<p><strong>远程推送</strong></p>
<p>远程推送消息调用时，launch option 会是 <code>UIApplicationLaunchOptionsRemoteNotificationKey</code>，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)applicationdidFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#10;&#123;&#10;  // ...&#10;&#10;    if (launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey]) &#123;&#10;       [self application:application didReceiveRemoteNotification:launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey]];&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本地推送</strong></p>
<p>本地推送launch options 会是 <code>UIApplicationLaunchOptionsLocalNotificationKey</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import AVFoundation;&#10;@interface AppDelegate ()&#10;@property (readwrite, nonatomic, assign) SystemSoundID localNotificationSound;&#10;@end&#10;&#10;- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification&#10;&#123;     &#10;    if (application.applicationState == UIApplicationStateActive) &#123;         &#10;   UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:notification.alertAction                                                               message:notification.alertBody                                                                 delegate:nil&#10;                                             cancelButtonTitle:NSLocalizedString(@&#34;OK&#34;, nil)                                                otherButtonTitles:nil];         &#10;   if (!self.localNotificationSound) &#123;             &#10;        NSURL *soundURL = [[NSBundle mainBundle] URLForResource:@&#34;Sosumi&#34;                                                                        withExtension:@&#34;wav&#34;];             &#10;     AudioServicesCreateSystemSoundID((__bridge CFURLRef)soundURL, &#38;_localNotificationSound);      &#125;         &#10;    AudioServicesPlaySystemSound(self.localNotificationSound);         &#10;    [alertView show];     &#10;  &#125;&#10;&#125;&#10;- (void)applicationWillTerminate:(UIApplication *)application &#123;     &#10;  if (self.localNotificationSound) &#123;         &#10;      AudioServicesDisposeSystemSoundID(self.localNotificationSound);     &#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>位置事件调用</strong></p>
<p>当由手机位置变动，调用app时，launch option 会是 <code>UIApplicationLaunchOptionsLocationKey</code>, key 是一个NSNumber 包含一个Boolean。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import CoreLocation;&#10;@interface AppDelegate () &#60;CLLocationManagerDelegate&#62;&#10;@property (readwrite, nonatomic, strong) CLLocationManager *locationManager;&#10;@end&#10;&#10;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;     &#10;  // ...     &#10;  if (![CLLocationManager locationServicesEnabled]) &#123;         &#10;  [[[UIAlertView alloc] initWithTitle:NSLocalizedString(@&#34;Location Services Disabled&#34;, nil)                                  message:NSLocalizedString(@&#34;You currently have all location services for this device disabled. If you proceed, you will be asked to confirm whether location services should be reenabled.&#34;, nil)                                    &#10;                             delegate:nil                           &#10;                    cancelButtonTitle:NSLocalizedString(@&#34;OK&#34;, nil)                                                otherButtonTitles:nil] show];     &#10;   &#125;&#10;   else &#123;         &#10;       self.locationManager = [[CLLocationManager alloc] init];         &#10;       self.locationManager.delegate = self;         &#10;       [self.locationManager startMonitoringSignificantLocationChanges];     &#10;   &#125;     &#10;   if (launchOptions[UIApplicationLaunchOptionsLocationKey]) &#123;         &#10;   [self.locationManager startUpdatingLocation];     &#10;   &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Newsstand</strong></p>
<p>launch option 会是 <code>UIApplicationLaunchOptionsNewsstandDownloadsKey</code>, 提示用户有新的Newsstand可以下载</p>
<p>蓝牙调用</p>
<p>iOS 7 中蓝牙分主从关系，所以对应的launch option key有两种</p>
<p><code>UIApplicationLaunchOptionsBluetoothCentralsKey</code></p>
<p><code>UIApplicationLaunchOptionsBluetoothPeripheralsKey</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;@import CoreBluetooth;&#10;@interface AppDelegate () &#60;CBCentralManagerDelegate&#62;&#10;@property (readwrite, nonatomic, strong) CBCentralManager *centralManager;&#10;@end&#10;&#10;self.centralManager = [[CBCentralManager alloc] initWithDelegate:self&#10;                                                         queue:nil&#10;                                                         options:@&#123;CBCentralManagerOptionRestoreIdentifierKey:(launchOptions[UIApplicationLaunchOptionsBluetoothCentralsKey] ?: [[NSUUID UUID] UUIDString])&#125;];&#10;if (self.centralManager.state == CBCentralManagerStatePoweredOn) &#123;     &#10;  static NSString * const UID = @&#34;7C13BAA0-A5D4-4624-9397-15BF67161B1C&#34;; // generated with `$ uuidgen`     &#10;  NSArray *services = @[[CBUUID UUIDWithString:UID]];     &#10;  NSDictionary *scanOptions = @&#123;CBCentralManagerScanOptionAllowDuplicatesKey:@YES&#125;;     &#10;  [self.centralManager scanForPeripheralsWithServices:services options:scanOptions];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://nshipster.com/launch-options/" target="_blank" rel="external">参考链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/03/05/UIApplicationDelegate-启动选项介绍/" data-id="cl4cdpts6001rjsv9iyucvjaf" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLite/">SQLite</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unix/">Unix</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/combine/">combine</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life/">life</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux-archlinux/">linux, archlinux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/phonegap/">phonegap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming/">programming</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading/">reading</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swift-source-code/">swift source code</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编辑器配置文件/">编辑器配置文件</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书/">读书</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 17.5px;">C</a> <a href="/tags/SQLite/" style="font-size: 10px;">SQLite</a> <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/Unix/" style="font-size: 10px;">Unix</a> <a href="/tags/combine/" style="font-size: 12.5px;">combine</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/life/" style="font-size: 10px;">life</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/linux-archlinux/" style="font-size: 10px;">linux, archlinux</a> <a href="/tags/phonegap/" style="font-size: 10px;">phonegap</a> <a href="/tags/programming/" style="font-size: 10px;">programming</a> <a href="/tags/reading/" style="font-size: 10px;">reading</a> <a href="/tags/swift-source-code/" style="font-size: 15px;">swift source code</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/编辑器配置文件/" style="font-size: 10px;">编辑器配置文件</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">十二月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">八月 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">四月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">三月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">二月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">十二月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">十一月 2013</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">十月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">八月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">六月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">三月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">十二月 2012</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">十一月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">五月 2012</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/13/信心/">信心</a>
          </li>
        
          <li>
            <a href="/2022/06/04/Combine-Publisher/">Combine: Publisher</a>
          </li>
        
          <li>
            <a href="/2022/05/30/Combine-Introduction/">Combine: Introduction</a>
          </li>
        
          <li>
            <a href="/2022/05/13/Swift-Source-Code-ContiguousArray/">Swift Source Code: ContiguousArray</a>
          </li>
        
          <li>
            <a href="/2022/05/11/Swift-Source-Code-Collection/">Swift Source Code: Collection</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Anyuan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">home</a>
  
    <a href="/archives" class="mobile-nav-link">archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>