<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Anyuan&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="Anyuan's blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Anyuan's blog">
<meta property="og:description" content="记录点滴">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Anyuan's blog">
<meta name="twitter:description" content="记录点滴">
  
    <link rel="alternative" href="/atom.xml" title="Anyuan&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Anyuan&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">home</a>
        
          <a class="main-nav-link" href="/archives">archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Best-Practices-for-Handling-Multitouch-Events" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/01/Best-Practices-for-Handling-Multitouch-Events/" class="article-date">
  <time datetime="2014-12-01T08:27:32.000Z" itemprop="datePublished">2014-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/01/Best-Practices-for-Handling-Multitouch-Events/">Best Practices for Handling Multitouch Events</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>Always implement the event cancelation methods.</p>
  <p>In your implementation, restore the state of a view to what it was before the current multitouch sequence. If you don’t, your view could be left in an inconsistent state, or in some cases, another view could receive the cancelation message.</p>
</li>
<li><p>If you handle events in a subclass of UIView, UIViewController, or UIResponder:</p>
<ul>
<li>Implement all of the event handling methods, even if your implementations of those methods do nothing.</li>
<li>Do not call the superclass implementation of the methods.</li>
</ul>
<p></p></li>
<li><p>If you handle events in a subclass of any other UIKit responder class:</p>
<ul>
<li>You do not have to implement all of the event handling methods.</li>
<li>In the methods you do implement, be sure to call the superclass implementation. For example, <code>[super touchesBegan:touches withEvent:event]</code>.</li>
</ul>
<p></p>
</li>
<li><p>Do not forward events to other responder objects of the UIKit Framework.</p>
<p>Instead, forward events to instances of your own subclasses of UIView. Additionally, make sure these responder objects are aware that event forwarding is taking place and tat they can receive touches that are not bound to them.</p>
</li>
<li><p>Do not explicitly send events up the responder chain through the nextResponder method; instead, invoke the superclass implementation and let UIKit handle responder-chain traversal.</p>
</li>
<li><p>Do not use round-to-integer code in your touch handling because you lose precision.</p>
<p>iOS reports touches in a 320x480 coordinate space to maintain source compatiblity. However, on high-resolution devices, the resolution is actually twice as high in each dimension(640x960), which means that touches can land on half-point boundaries on high-resolution devices. On older devices, touches land only on full-point boundaries.</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/12/01/Best-Practices-for-Handling-Multitouch-Events/" data-id="cl34e5n450000otozyp0w6a27" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-企业证书签名包ipa无线安装服务器搭建注意事项" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/26/iOS-企业证书签名包ipa无线安装服务器搭建注意事项/" class="article-date">
  <time datetime="2014-08-26T08:26:34.000Z" itemprop="datePublished">2014-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/26/iOS-企业证书签名包ipa无线安装服务器搭建注意事项/">iOS 企业证书签名包ipa无线安装服务器搭建注意事项</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>因为iOS 7.1以后要求链接地址为https(itms-services://?action=download-manifest&amp;url=<a href="https://10.208.99.199/ota/ios/plist/8239)，所以apache服务器要开启https，具体步骤参见：http://www.cnblogs.com/y500/p/3596473.html" target="_blank" rel="external">https://10.208.99.199/ota/ios/plist/8239)，所以apache服务器要开启https，具体步骤参见：http://www.cnblogs.com/y500/p/3596473.html</a></li>
</ol>
<p>在以上步骤需要注意的是，生成SSL证书时，输入的common name要以服务器地址名称一致，如10.208.99.199或者域名，或者</p>
<pre><code>10.<span class="keyword">*</span>.<span class="keyword">*</span>.<span class="keyword">*</span>
</code></pre><p> 通配符形式。</p>
<ol>
<li><p>apache配置文件httpd.conf, httpd-ssl.conf, httpd-vhost.conf三个文件中的ServerName 都要配成与证书适配的名称，如10.208.99.199， 此处一定要保持一致。</p>
</li>
<li><p>在apache httpd.conf配置文件中添加</p>
<pre><code><span class="keyword">AddType </span>application/octet-<span class="keyword">stream </span>ipa
</code></pre></li>
</ol>
<p>, 是为Mac OS X上的配置，其他请上网查阅一下。</p>
<ol>
<li><p>启动apache服务器</p>
<pre><code>sudo apachectl -<span class="keyword">D</span> SSL -k restart
</code></pre></li>
</ol>
<p>通过以上配置，应该是可以搭建无线安装ipa的服务器了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/26/iOS-企业证书签名包ipa无线安装服务器搭建注意事项/" data-id="cl34e5n5n000rotozxvr88csu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-Web-py网站迁移Mac-OS-X" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/23/Linux-Web-py网站迁移Mac-OS-X/" class="article-date">
  <time datetime="2014-08-23T08:25:35.000Z" itemprop="datePublished">2014-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/23/Linux-Web-py网站迁移Mac-OS-X/">Linux Web.py网站迁移Mac OS X</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>数据库导出</p>
<pre><code>mysqldump --opt -u name -<span class="tag">p</span> dbname &gt; backupfile.sql
</code></pre></li>
<li><p>在Mac OS X上安装web.py环境<br>0）install web.py</p>
<pre><code>sudo pip <span class="keyword">install</span> web.py
</code></pre></li>
</ol>
<p>1) 安装mod_wsgi<br>下载mod_wsgi</p>
<p><a href="http://code.google.com/p/modwsgi/wiki/DownloadTheSoftware?tm=2" target="_blank" rel="external">http://code.google.com/p/modwsgi/wiki/DownloadTheSoftware?tm=2</a></p>
<p>解压，</p>
<pre><code>./configure

<span class="built_in">make</span>

sudo <span class="built_in">make</span> install
</code></pre><p>2) 配置apache httpd.conf</p>
<pre><code>#<span class="operator"><span class="keyword">Load</span> mod_wsgi <span class="keyword">module</span>:
LoadModule wsgi_module libexec/apache2/mod_wsgi.so

WSGIScriptAlias /ota /<span class="keyword">Users</span>/iosteam/ota_all/website.py/

AddType <span class="built_in">text</span>/html .py

<span class="keyword">Alias</span> /ota/<span class="keyword">static</span> <span class="string">"/Users/iosteam/ota_all/static"</span>

&lt;<span class="keyword">Directory</span> <span class="string">"/Users/iosteam/ota_all"</span>&gt;

  <span class="keyword">Order</span> deny,<span class="keyword">allow</span>

  <span class="keyword">Allow</span> <span class="keyword">from</span> all

&lt;/<span class="keyword">Directory</span>&gt;</span>
</code></pre><p>3) 如果仍不能访问，修改对应的webpy启动文件</p>
<pre><code><span class="comment"># for mod_python</span>

app = web.<span class="type">application</span>(urls, globals())

<span class="type">application</span> = app.wsgifunc()
</code></pre><ol>
<li><p>导入数据库数据</p>
<pre><code>mysql -u root -<span class="tag">p</span> &lt; database.sql
</code></pre></li>
<li><p>安装python连接数据库包</p>
<pre><code>sudo pip search MySQL_python
sudo pip <span class="keyword">install</span> MySQL_python
</code></pre></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/23/Linux-Web-py网站迁移Mac-OS-X/" data-id="cl34e5n6g002dotozetn570xj" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-服务器高I-O-等待延迟问题查找" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/17/Linux-服务器高I-O-等待延迟问题查找/" class="article-date">
  <time datetime="2014-08-17T08:24:51.000Z" itemprop="datePublished">2014-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/17/Linux-服务器高I-O-等待延迟问题查找/">Linux 服务器高I/O 等待延迟问题查找</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>首先是top查看一下系统状况</li>
</ol>
<p>发现两个参数异常，一是平均负载高，一是cpu %wa一直在50%以上。</p>
<p>查了一下%wa参数的意义：</p>
<pre><code>wa <span class="comment">-- iowait</span>
 Amount <span class="operator">of</span> <span class="built_in">time</span> <span class="operator">the</span> CPU has been waiting <span class="keyword">for</span> I/O <span class="built_in">to</span> complete.
</code></pre><ol>
<li>查看磁盘读写数据</li>
</ol>
<p>用iostat 查看磁盘状况</p>
<pre><code>$ iostat -x <span class="number">2</span> <span class="number">5</span>
 avg-cpu: %user %nice %system %iowait %steal %idle
  <span class="number">3.66</span> <span class="number">0.00</span> <span class="number">47.64</span> <span class="number">48.69</span> <span class="number">0.00</span> <span class="number">0.00</span>

 Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util
 sda <span class="number">44.50</span> <span class="number">39.27</span> <span class="number">117.28</span> <span class="number">29.32</span> <span class="number">11220.94</span> <span class="number">13126.70</span> <span class="number">332.17</span> <span class="number">65.77</span> <span class="number">462.79</span> <span class="number">9.80</span> <span class="number">2274.71</span> <span class="number">7.60</span> <span class="number">111.41</span>
 dm-<span class="number">0</span> <span class="number">0.00</span> <span class="number">0.00</span> <span class="number">83.25</span> <span class="number">9.95</span> <span class="number">10515.18</span> <span class="number">4295.29</span> <span class="number">317.84</span> <span class="number">57.01</span> <span class="number">648.54</span> <span class="number">16.73</span> <span class="number">5935.79</span> <span class="number">11.48</span> <span class="number">107.02</span>
 dm-<span class="number">1</span> <span class="number">0.00</span> <span class="number">0.00</span> <span class="number">57.07</span> <span class="number">40.84</span> <span class="number">228.27</span> <span class="number">163.35</span> <span class="number">8.00</span> <span class="number">93.84</span> <span class="number">979.61</span> <span class="number">13.94</span> <span class="number">2329.08</span> <span class="number">10.93</span> <span class="number">107.02</span>
</code></pre><p>2.查看进程状态<br>进程状态表</p>
<pre><code>PROCESS STATE CODES
 D uninterruptible sleep (usually IO)
 R <span class="property">running</span> <span class="keyword">or</span> runnable (<span class="function_start"><span class="keyword">on</span></span> <span class="command">run</span> queue)
 S interruptible sleep (waiting <span class="keyword">for</span> an event <span class="keyword">to</span> complete)
 T stopped, either <span class="keyword">by</span> a job control signal <span class="keyword">or</span> because <span class="keyword">it</span> <span class="keyword">is</span> being traced.
 W paging (<span class="keyword">not</span> valid <span class="keyword">since</span> <span class="keyword">the</span> <span class="number">2.6</span>.xx kernel)
 X dead (should never be seen)
 Z defunct (<span class="string">"zombie"</span>) process, terminated <span class="keyword">but</span> <span class="keyword">not</span> reaped <span class="keyword">by</span> <span class="keyword">its</span> parent.
</code></pre><p>查看到进程中状态D（disk sleep）的进程</p>
<pre><code># <span class="keyword">for</span> <span class="keyword">x</span> in `seq <span class="number">1</span> <span class="number">1</span> <span class="number">10</span>`; <span class="keyword">do</span> <span class="keyword">ps</span> -eo state,pid,cmd | <span class="keyword">grep</span> <span class="string">"^D"</span>; <span class="keyword">echo</span> <span class="string">"----"</span>; <span class="keyword">sleep</span> <span class="number">5</span>; done
</code></pre><p>查看到有kjournald这个进程<br>查看这个进程是做什么的？</p>
<p>kjournald是ext3文件系统记录文件系统日志的进程。</p>
<p>查看进程相关状态信息</p>
<pre><code><span class="preprocessor"># cat /proc/<span class="number">487</span>/io</span>
 rchar: <span class="number">48752567</span>
 wchar: <span class="number">549961789</span>
 syscr: <span class="number">5967</span>
 syscw: <span class="number">67138</span>
 read_bytes: <span class="number">49020928</span>
 write_bytes: <span class="number">549961728</span>
 cancelled_write_bytes: <span class="number">0</span>
</code></pre><p>查看都往哪写东西了</p>
<pre><code><span class="preprocessor"># lsof -p <span class="number">487</span></span>
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/17/Linux-服务器高I-O-等待延迟问题查找/" data-id="cl34e5n6g002botozfh6chnnw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-GCD常用函数总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/04/19/iOS-GCD常用函数总结/" class="article-date">
  <time datetime="2014-04-19T07:58:16.000Z" itemprop="datePublished">2014-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/19/iOS-GCD常用函数总结/">iOS GCD常用函数总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>GCD提供两种Dispatch Queue, 分别为Concurrent Dispatch Queue 和 Serial Dispatch Queue.</p>
<p>Serial Dispatch Queue 使用一个thread。</p>
<p>Concurrent Dispatch Queue 使用多个thread。</p>
<p>获取Dispatch Queue:</p>
<p>0）dispatch_queue_create</p>
<pre><code><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"name.of.your.queue"</span>,<span class="literal">NULL</span>);
</code></pre><p>第一个参数为queue的名字，第二个参数传NULL表明要创建一个Serial Dispatch Queue, 传入DISPATCH_QUEUE_CONCURRENT 创建一个 Concurrent Dispatch Queue。<br>如果是对数据库表更新或更新文件，最好为每一个表或文件建立一个Serial Dispatch Queue，这样能保证只有一个thread会对数据进行更新。</p>
<p>如果对那些不会引起数据不一致问题的任务，需要放到Concurrent Dispatch Queue执行。</p>
<p>1）从Main Dispatch Queue/Global Dispatch Queue获取</p>
<pre><code><span class="comment">//main queue</span>
<span class="keyword">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();

<span class="comment">//global queue of high priority</span>
<span class="keyword">dispatch_queue_t</span> globalHigh =         dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,<span class="number">0</span>);

<span class="comment">//global queue of default priority</span>
<span class="keyword">dispatch_queue_t</span> globalDefault =     dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);

<span class="comment">//global queue of low priority</span>
<span class="keyword">dispatch_queue_t</span> globalLow = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW,<span class="number">0</span>);

<span class="comment">//global queue of background priority</span>
<span class="keyword">dispatch_queue_t</span> globalBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,<span class="number">0</span>);
</code></pre><p>Main Dispatch Queue -&gt; Serial dispatch queue<br>Global Dispatch Queue -&gt; Concurrent dispatch queue</p>
<p>dispatch_set_target_queue: 主要用来给新建的queue设置优先级</p>
<pre><code>dispatch_queue_t serialQueue = dispatch_queue_create<span class="list">(<span class="string">"name.of.queue"</span>,NULL)</span><span class="comment">;</span>

dispatch_queue_t globalQueue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_BACKGROUND</span>,<span class="number">0</span>)</span><span class="comment">;</span>

dispatch_set_target_queue<span class="list">(<span class="keyword">serialQueue</span>, globalQueue)</span><span class="comment">;</span>
</code></pre><p>需要注意的是，第一个参数是自定义的queue，而不是系统的queue。因为你不能给系统的queue设置权限。通过上面设置，serialQueue 就有了与globalQueue一样的优先级。其实这个函数不仅可以设置queue的优先级，还可以设置queue之间的层级结构。</p>
<p>dispatch_after: 过一段时间执行queue中的task</p>
<pre><code>dispatch_time_t <span class="property">time</span> = dispatch_time(DISPATCH_TIME_NOW, <span class="number">3</span>ull * NSEC_PER_SEC);

dispatch_after(<span class="property">time</span>, dispatch_get_main_queue(),^{
           NSLog(@<span class="string">"after 3 seconds..."</span>);});
</code></pre><p>Dispatch Group</p>
<p>0）dispatch_group_notify</p>
<p>dispatch group 可以在group中的dispatch queue都执行完之后，通过一个dispatch_group_notify通知回调。</p>
<pre><code>dispatch_queue_t queue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>,<span class="number">0</span>)</span><span class="comment">;</span>

dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span>

dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^{NSLog<span class="list">(@<span class="string">"task1"</span>)</span><span class="comment">;});</span>
dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^{NSLog<span class="list">(@<span class="string">"task2"</span>)</span><span class="comment">;});</span>
dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^{NSLog<span class="list">(@<span class="string">"task3"</span>)</span><span class="comment">;});</span>

dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^{NSLog<span class="list">(@<span class="string">"finished..."</span>)</span><span class="comment">;});</span></span></span></span></span>
</code></pre><p>输出总会保证”finished…”会在最后一句输出。</p>
<pre><code><span class="number">1</span>）dispatch_group_wait

dispatch_queue_t <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);

dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();

dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{NSLog(@<span class="string">"task1"</span>);});
dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{NSLog(@<span class="string">"task2"</span>);});
dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{NSLog(@<span class="string">"task3"</span>);});

dispatch_group_wait(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER);
</code></pre><p>dispatch_group_wait提供了一种类似超时的机制，当然如果等待时间设置为DISPATCH_TIME_FOREVER,功能和dispatch_group_notify是一样的。</p>
<p>dispatch_barrier_async</p>
<p>dispatch_barrier_async是一个可以让当前任务等待queue其他任务完成再执行的函数。例如，从数据库读取数据是可以多线程并发读取的，因为这样提高效率。但是，更新数据库数据，就要保证只有一个线程进行更新操作。所以，当更新操作发生的时候，一定要保证读操作和其他更新操作等待。</p>
<pre><code>dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"barrier.queue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span>

dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_0)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_1)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_2)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_3)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_4)</span><span class="comment">;</span>

dispatch_barrier_async<span class="list">(<span class="keyword">queue</span>, update_block)</span><span class="comment">;</span>

dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_5)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_6)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_7)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_8)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_9)</span><span class="comment">;</span>
</code></pre><p>这样就可以保证只有当更新操作结束后，才会进行其他数据库读操作，保证了数据的一致性。</p>
<p>dispatch_apply</p>
<p>dispatch_apply用于给一个block添加到dispatch queue若干次。 “for”循环</p>
<pre><code><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);

dispatch_apply(<span class="number">10</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> index) { NSLog(@<span class="string">"%zu"</span>,index);});

NSLog(@<span class="string">"done..."</span>);
</code></pre><p>dispatch_suspend/dispatch_resume</p>
<p>用于暂停和继续执行queue</p>
<p>dispatch semaphore</p>
<p>dispatch semaphore 适合处理比dispatch queue或者dispatch_barrier_async更小颗粒度的操作。</p>
<p>例如，</p>
<pre><code><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);

NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];

<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)
{
dispatch_async(<span class="built_in">queue</span>, ^{
  [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:i]];
});
}
</code></pre><p>如果执行上段代码，因为NSMutableArray不是thread safe的，所以在global queue中对其进行添加对象，会导致程序crash掉。</p>
<p>使用dispatch semaphore我们可以实现多线程对NSMutableArray进行操作</p>
<pre><code><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);

<span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>);

NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];

<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)
{
dispatch_async(<span class="built_in">queue</span>, ^{

  dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);

  [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:i]];

  dispatch_semaphore_signal(semaphore);
});
}
</code></pre><p>dispatch semaphore 是一个信号量的counter，当counter为0，当前线程停止运行，当大于0，自减1，继续执行。</p>
<p>dispatch_semaphore_create</p>
<pre><code><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>);
</code></pre><p>初始化一个counter为1的semaphore.<br>dispatch_semaphore_wait</p>
<pre><code>dispatch_semaphore_wait<span class="list">(<span class="keyword">semaphore</span>, DISPATCH_TIME_FOREVER)</span><span class="comment">;</span>
</code></pre><p>等待counter大于0才运行，第二个参数为等待时间。执行后counter减1.</p>
<p>dispatch_semaphore_signal</p>
<pre><code>dispatch_semaphore_signal<span class="list">(<span class="keyword">semaphore</span>)</span><span class="comment">;</span>
</code></pre><p>给counter加1<br>所以在上面的代码中，就可以保证在wait和signal中的[array addObject:[NSNumber numberWithInt:i]]; 就只有一个thread进行操作，保证了线程安全。</p>
<p>dispatch_onece</p>
<p>保证了dispatch_once中的代码只会被执行一次，常用于单例。</p>
<pre><code>+ (<span class="keyword">id</span>)sharedManager {
<span class="keyword">static</span> MyManager *sharedMyManager = <span class="literal">nil</span>;
<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
<span class="built_in">dispatch_once</span>(&amp;onceToken, ^{
    sharedMyManager = [[<span class="keyword">self</span> alloc] init];
});
<span class="keyword">return</span> sharedMyManager;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/04/19/iOS-GCD常用函数总结/" data-id="cl34e5n5x0015otoz9kj53jqy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-Block实现探究" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/04/06/iOS-Block实现探究/" class="article-date">
  <time datetime="2014-04-06T08:22:21.000Z" itemprop="datePublished">2014-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/06/iOS-Block实现探究/">iOS Block实现探究</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用clang的rewrite-objc filename 可以将有block的c代码转换成cpp代码。从中可以看到block的实现。</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
  <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^{
    <span class="built_in">printf</span>(<span class="string">"Block\n"</span>);
  };
  blk();
  <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>使用clang rewrite-objc以后会看到block的实现</p>
<pre><code><span class="keyword">struct</span> __main_block_impl_0 {
 <span class="keyword">struct</span> __block_impl <span class="keyword">impl</span>;
 <span class="keyword">struct</span> __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>)
{
<span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;
<span class="keyword">impl</span>.Flags = flags;
<span class="keyword">impl</span>.FuncPtr = fp;
Desc = desc;
 }
};
</code></pre><p>可以看到其实block是一个正常的OC类</p>
<p>来看看block是怎样访问外部变量的</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
  <span class="keyword">int</span> dmy = <span class="number">256</span>;
  <span class="keyword">int</span> val = <span class="number">10</span>;
  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"val = %d\n"</span>;
  <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^{
    <span class="built_in">printf</span>(fmt, val);
  };
  <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>转换之后，可以看到</p>
<pre><code><span class="keyword">struct</span> __main_block_impl_0 {
  <span class="keyword">struct</span> __block_impl impl;
  <span class="keyword">struct</span> __main_block_desc_0* Desc;
  <span class="keyword">const</span> <span class="keyword">char</span> *fmt;
  <span class="keyword">int</span> val;
  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">const</span> <span class="keyword">char</span> *_fmt, <span class="keyword">int</span> _val, <span class="keyword">int</span> flags=<span class="number">0</span>) : fmt(_fmt), val(_val) {
impl.isa = &amp;_NSConcreteStackBlock;
impl.Flags = flags;
impl.FuncPtr = fp;
Desc = desc;
  }
};


<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
  <span class="keyword">int</span> dmy = <span class="number">256</span>;
  <span class="keyword">int</span> val = <span class="number">10</span>;
  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"val = %d\n"</span>;
  <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val);
  <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>block的变量会被复制进block中</p>
<p>如果当block要改变传入的变量值怎么办？首先看一下全局变量和本地静态变量</p>
<pre><code><span class="keyword">int</span> global_val = <span class="number">1</span>;
<span class="keyword">static</span> <span class="keyword">int</span> static_global_val = <span class="number">2</span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
  <span class="keyword">static</span> <span class="keyword">int</span> static_val = <span class="number">3</span>;
  <span class="keyword">void</span>(^blk)(<span class="keyword">void</span>) = ^{
  global_val *= <span class="number">1</span>;
   static_global_val *= <span class="number">2</span>;
  static_val *= <span class="number">3</span>;
  };
  blk();
  <span class="keyword">return</span> <span class="number">0</span>;
}



<span class="keyword">struct</span> __main_block_impl_0 {
  <span class="keyword">struct</span> __block_impl impl;
  <span class="keyword">struct</span> __main_block_desc_0* Desc;
  <span class="keyword">int</span> *static_val;
  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> *_static_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : static_val(_static_val) {
impl.isa = &amp;_NSConcreteStackBlock;
impl.Flags = flags;
impl.FuncPtr = fp;
Desc = desc;
  }
};
<span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) {
  <span class="keyword">int</span> *static_val = __cself-&gt;static_val; <span class="comment">// bound by copy</span>

global_val *= <span class="number">1</span>;
static_global_val *= <span class="number">2</span>;
(*static_val) *= <span class="number">3</span>;
}
</code></pre><p>由于全局变量是在Data Section中，所以直接可以访问。局部静态变量是通过将其指针传入到block中，block就可以对其值进行修改。</p>
<p>然后看一下__block修饰符变量</p>
<pre><code><span class="type">int</span> main()
{
  __block <span class="type">int</span> val = <span class="number">10</span>;
  <span class="type">void</span> (^blk)(<span class="type">void</span>) = ^{val = <span class="number">1</span>;};
  blk();
  <span class="keyword">return</span> <span class="number">0</span>;
}

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* <span class="type">Desc</span>;
  __Block_byref_val_0 *val; // by <span class="keyword">ref</span>
  __main_block_impl_0(<span class="type">void</span> *fp, struct __main_block_desc_0 *desc,             __Block_byref_val_0 *_val, <span class="type">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) {
impl.isa = &amp;_NSConcreteStackBlock;
impl.<span class="type">Flags</span> = flags;
impl.<span class="type">FuncPtr</span> = fp;
<span class="type">Desc</span> = desc;
  }
};
<span class="keyword">static</span> <span class="type">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_val_0 *val = __cself-&gt;val; // bound by <span class="keyword">ref</span>
(val-&gt;__forwarding-&gt;val) = <span class="number">1</span>;}
<span class="keyword">static</span> <span class="type">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src)
</code></pre><p><strong>block修饰符的变量，会生成一个</strong>Block_byref_val_0的struct，然后通过访问其<strong>forwarding来访问val值。因为Block有可能是在stack或者heap中，所以用</strong>forwarding来访问。之所以会将__block单独生成一个struct是因为可能该变量会被多个block使用。</p>
<p>Block分三种类型</p>
<p>0) NSConcreteStackBlock    –stack</p>
<p>1) NSConcreteGlobalBlock   –data area</p>
<p>2) NSConcreteMallocBlock   –heap</p>
<p>自动copy block</p>
<p>当开启ARC时，在某些情况编译器会自动copy block，从stack到heap。</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">int</span> （^<span class="keyword">blk_t</span>)(<span class="keyword">int</span>);
<span class="keyword">blk_t</span> func(<span class="keyword">int</span> rate)
{
  <span class="keyword">return</span> ^(<span class="keyword">int</span> count){<span class="keyword">return</span> rate * count;};
}


<span class="keyword">blk_t</span> func(<span class="keyword">int</span> rate)
{
  <span class="keyword">blk_t</span> tmp = &amp;__func_block_impl_0(
__func_block_func_0, &amp;__func_block_desc_0_DATA, rate);

  tmp = objc_retainBlock(tmp);
  <span class="keyword">return</span> objc_autoreleaseReturnValue(tmp);
}
</code></pre><p>有些情况，编译器是无法检测是否应该copy block：</p>
<p>当block作为参数传递到方法或函数中。</p>
<p>但是，如果该方法或函数在内部copy，就不用手动再copy：</p>
<p>0）cocoa framework方法， 有usingBlock</p>
<p>1) GCD API</p>
<pre><code>- (<span class="keyword">id</span>) getBlockArray
{
  <span class="keyword">int</span> val = <span class="number">10</span>;
  <span class="keyword">return</span> [[<span class="built_in">NSArray</span> alloc] initWithObjects:
 [^{<span class="built_in">NSLog</span>(<span class="string">@"blk0:%d"</span>, val);} <span class="keyword">copy</span>],
 [^{<span class="built_in">NSLog</span>(<span class="string">@"blk1:%d"</span>, val);} <span class="keyword">copy</span>], <span class="literal">nil</span>];
}
</code></pre><p>__forwarding</p>
<p>当block从stack copy到 heap中时，block中用到的<strong>block也会copy到heap中，并且copy到heap中的block拥有该</strong>block。</p>
<pre><code>__block int <span class="keyword">val</span> = <span class="number">0</span>;
<span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = [^{++<span class="keyword">val</span>;} copy];
++<span class="keyword">val</span>;
blk();
NSLog(<span class="string">@"%d"</span>, <span class="keyword">val</span>);
</code></pre><p>在block和外的++val都会变成 ++(val.<strong>forwarding-&gt;val);<br>当block copy到heap中后， stack中的</strong>forwarding会指向heap中的<strong>block, heap中的</strong>forwarding会指向自己的<strong>block值，这样保证了</strong>forwarding指向的是同一个变量值。</p>
<p>Block什么时候会copy到heap中</p>
<p>0）对block调用copy方法。</p>
<p>1）block作为一个函数的返回值。 编译器自动copy</p>
<p>2）赋值给id或block type class 有__strong 修饰符的成员变量。   编译器自动copy</p>
<p>3）usingBlock, GCD API。  在函数内copy</p>
<p>什么时候用该copy block？</p>
<p>0） block是函数返回值</p>
<p>1） block赋值给id或block type class 有__strong 修饰符的成员变量。</p>
<p>2）3）usingBlock, GCD API。  在函数内copy</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/04/06/iOS-Block实现探究/" data-id="cl34e5n60001botoz7hnsk3hb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-UIApplicationDelegate-启动选项介绍" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/03/05/UIApplicationDelegate-启动选项介绍/" class="article-date">
  <time datetime="2014-03-05T08:19:36.000Z" itemprop="datePublished">2014-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/03/05/UIApplicationDelegate-启动选项介绍/">UIApplicationDelegate 启动选项介绍</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#10;&#123;&#10;  // Override point for customization after application launch.&#10;  return YES;&#10;&#125;&#10;&#10;- (void)applicationWillResignActive:(UIApplication *)application&#10;&#123;&#10;  // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.&#10;  // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.&#10;&#125;&#10;&#10;- (void)applicationDidEnterBackground:(UIApplication *)application&#10;&#123;&#10;  // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.&#10;  // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.&#10;&#125;&#10;&#10;- (void)applicationWillEnterForeground:(UIApplication *)application&#10;&#123;&#10;  // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.&#10;&#125;&#10;&#10;- (void)applicationDidBecomeActive:(UIApplication *)application&#10;&#123;&#10;  // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.&#10;&#125;&#10;&#10;- (void)applicationWillTerminate:(UIApplication *)application&#10;&#123;&#10;  // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>每个iOS app的入口都是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</span><br></pre></td></tr></table></figure>
<p>当app启动完成，准备运行时，application会调用自己的这个代理方法。</p>
<p>一个app除了点击图标进行启动，还有一些其他方式调用一个app。区别不同启动方式，就需要用到launchOptions. 与userInfo 字典相似，<code>-application:didFinishLaunchingWithOptions:</code> 可以通过launchOptions获取启动信息的key。</p>
<p><strong>通过URL启动</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[UIApplication sharedApplication] openURL:[NSURL URLWithString:@&#34;app://...&#34;]];</span><br></pre></td></tr></table></figure>
<p><a href="http://URL" target="_blank" rel="external">http://URL</a> 会调用Safari， mailto://URL 会打开邮箱， tel://URL 会拨打电话。</p>
<p>这种情况下<code>launchOptions</code> 为<code>UIApplicationLaunchOptionsURLKey</code></p>
<p>app通过URL调用时，还可以有一些系统信息。 当通过<code>UIDocumentInteractionController</code> 或者 AirDrop 调用时，<code>launchedOptions</code> 会被设置为：</p>
<p><code>UIApplicationLaunchOptionsSourceApplicationKey:</code> key值是一个NSString，表示要调用你app的app bundle ID</p>
<p><code>UIApplicationLaunchOptionsAnnotationKey:</code> key可以存储property-list 对象。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NSURL *fileURL = [[NSBundle mainBundle] URLForResource:@&#34;Document&#34; withExtension:@&#34;pdf&#34;];&#10;if (fileURL) &#123;&#10;  UIDocumentInteractionController *documentInteractionController =&#10;  [UIDocumentInteractionController interactionControllerWithURL:fileURL];&#10;&#10;  documentInteractionController.annotation = @&#123;@&#34;foo&#34;: @&#34;bar&#34;&#125;;&#10;  [documentInteractionController setDelegate:self];&#10;  [documentInteractionController presentPreviewAnimated:YES];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>推送消息调用</strong></p>
<p><strong>远程推送</strong></p>
<p>远程推送消息调用时，launch option 会是 <code>UIApplicationLaunchOptionsRemoteNotificationKey</code>，</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)application:(UIApplication *)applicationdidFinishLaunchingWithOptions:(NSDictionary *)launchOptions&#10;&#123;&#10;  // ...&#10;&#10;    if (launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey]) &#123;&#10;       [self application:application didReceiveRemoteNotification:launchOptions[UIApplicationLaunchOptionsRemoteNotificationKey]];&#10;    &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>本地推送</strong></p>
<p>本地推送launch options 会是 <code>UIApplicationLaunchOptionsLocalNotificationKey</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import AVFoundation;&#10;@interface AppDelegate ()&#10;@property (readwrite, nonatomic, assign) SystemSoundID localNotificationSound;&#10;@end&#10;&#10;- (void)application:(UIApplication *)application didReceiveLocalNotification:(UILocalNotification *)notification&#10;&#123;     &#10;    if (application.applicationState == UIApplicationStateActive) &#123;         &#10;   UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:notification.alertAction                                                               message:notification.alertBody                                                                 delegate:nil&#10;                                             cancelButtonTitle:NSLocalizedString(@&#34;OK&#34;, nil)                                                otherButtonTitles:nil];         &#10;   if (!self.localNotificationSound) &#123;             &#10;        NSURL *soundURL = [[NSBundle mainBundle] URLForResource:@&#34;Sosumi&#34;                                                                        withExtension:@&#34;wav&#34;];             &#10;     AudioServicesCreateSystemSoundID((__bridge CFURLRef)soundURL, &#38;_localNotificationSound);      &#125;         &#10;    AudioServicesPlaySystemSound(self.localNotificationSound);         &#10;    [alertView show];     &#10;  &#125;&#10;&#125;&#10;- (void)applicationWillTerminate:(UIApplication *)application &#123;     &#10;  if (self.localNotificationSound) &#123;         &#10;      AudioServicesDisposeSystemSoundID(self.localNotificationSound);     &#10;  &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>位置事件调用</strong></p>
<p>当由手机位置变动，调用app时，launch option 会是 <code>UIApplicationLaunchOptionsLocationKey</code>, key 是一个NSNumber 包含一个Boolean。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@import CoreLocation;&#10;@interface AppDelegate () &#60;CLLocationManagerDelegate&#62;&#10;@property (readwrite, nonatomic, strong) CLLocationManager *locationManager;&#10;@end&#10;&#10;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;     &#10;  // ...     &#10;  if (![CLLocationManager locationServicesEnabled]) &#123;         &#10;  [[[UIAlertView alloc] initWithTitle:NSLocalizedString(@&#34;Location Services Disabled&#34;, nil)                                  message:NSLocalizedString(@&#34;You currently have all location services for this device disabled. If you proceed, you will be asked to confirm whether location services should be reenabled.&#34;, nil)                                    &#10;                             delegate:nil                           &#10;                    cancelButtonTitle:NSLocalizedString(@&#34;OK&#34;, nil)                                                otherButtonTitles:nil] show];     &#10;   &#125;&#10;   else &#123;         &#10;       self.locationManager = [[CLLocationManager alloc] init];         &#10;       self.locationManager.delegate = self;         &#10;       [self.locationManager startMonitoringSignificantLocationChanges];     &#10;   &#125;     &#10;   if (launchOptions[UIApplicationLaunchOptionsLocationKey]) &#123;         &#10;   [self.locationManager startUpdatingLocation];     &#10;   &#125;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Newsstand</strong></p>
<p>launch option 会是 <code>UIApplicationLaunchOptionsNewsstandDownloadsKey</code>, 提示用户有新的Newsstand可以下载</p>
<p>蓝牙调用</p>
<p>iOS 7 中蓝牙分主从关系，所以对应的launch option key有两种</p>
<p><code>UIApplicationLaunchOptionsBluetoothCentralsKey</code></p>
<p><code>UIApplicationLaunchOptionsBluetoothPeripheralsKey</code></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;@import CoreBluetooth;&#10;@interface AppDelegate () &#60;CBCentralManagerDelegate&#62;&#10;@property (readwrite, nonatomic, strong) CBCentralManager *centralManager;&#10;@end&#10;&#10;self.centralManager = [[CBCentralManager alloc] initWithDelegate:self&#10;                                                         queue:nil&#10;                                                         options:@&#123;CBCentralManagerOptionRestoreIdentifierKey:(launchOptions[UIApplicationLaunchOptionsBluetoothCentralsKey] ?: [[NSUUID UUID] UUIDString])&#125;];&#10;if (self.centralManager.state == CBCentralManagerStatePoweredOn) &#123;     &#10;  static NSString * const UID = @&#34;7C13BAA0-A5D4-4624-9397-15BF67161B1C&#34;; // generated with `$ uuidgen`     &#10;  NSArray *services = @[[CBUUID UUIDWithString:UID]];     &#10;  NSDictionary *scanOptions = @&#123;CBCentralManagerScanOptionAllowDuplicatesKey:@YES&#125;;     &#10;  [self.centralManager scanForPeripheralsWithServices:services options:scanOptions];&#10;&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://nshipster.com/launch-options/" target="_blank" rel="external">参考链接</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/03/05/UIApplicationDelegate-启动选项介绍/" data-id="cl34e5n66001ootozuviqqcbl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS7-nested-push-animation-can-result-in-corrupted" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/02/19/iOS7-nested-push-animation-can-result-in-corrupted/" class="article-date">
  <time datetime="2014-02-19T06:17:53.000Z" itemprop="datePublished">2014-02-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/02/19/iOS7-nested-push-animation-can-result-in-corrupted/">iOS7 nested push animation can result in corrupted</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在iOS7中，开启push/pop view controller 动画遇到一个问题，就是在快速切换多次后会在console出现一个问题</p>
<pre><code>nested push animation can <span class="literal">result</span> <span class="keyword">in</span> corrupted navigation bar multiple warning
<span class="type">Unbalanced</span> calls to begin/<span class="keyword">end</span> appearance transitions <span class="keyword">for</span>
</code></pre><p>查了一些资料后，找到了一个方法：</p>
<p>0）找到push/pop view controller 动画结束的回调。</p>
<p>UINavigationControllerDelegate代理中的</p>
<pre><code><span class="pp">-<span class="params">(void)</span>navigationController:<span class="params">(<span class="variable">UINavigationController</span> *)</span>navigationController
  didShowViewController:<span class="params">(<span class="variable">UIViewController</span> *)</span>viewController
               animated:<span class="params">(<span class="variable">BOOL</span>)</span>animated</span>
</code></pre><p>1）找到是否接受点击方法的方法。</p>
<p>UIGestureRecognizerDelegate中的</p>
<pre><code><span class="pp">-<span class="params">(<span class="variable">BOOL</span>)</span>gestureRecognizer:<span class="params">(<span class="variable">UIGestureRecognizer</span> *)</span>gestureRecognizer shouldReceiveTouch:<span class="params">(<span class="variable">UITouch</span> *)</span>touch</span>
</code></pre><p>应用以上两个代理方法，加上一个BOOL的flag值，可以控制是否处罚pop/push</p>
<p>当动画完成时，将flag设置为允许pop/push， <code>shouldReceiveTouch</code>直接返回flag值。</p>
<p>在点击事件时，要注意更改flag值不再接受其他事件，防止在flag为YES时的多次点击。</p>
<p>参考链接：</p>
<p><a href="http://stackoverflow.com/questions/11813091/nested-push-animation-can-result-in-corrupted-navigation-bar-multiple-warning" target="_blank" rel="external">http://stackoverflow.com/questions/11813091/nested-push-animation-can-result-in-corrupted-navigation-bar-multiple-warning</a></p>
<p><a href="http://www.taofengping.com/2013/12/26/ios7_barbuttonitem_navigation_gesture/" target="_blank" rel="external">http://www.taofengping.com/2013/12/26/ios7_barbuttonitem_navigation_gesture/</a></p>
<p><a href="http://blog.csdn.net/lengshengren/article/details/12616217" target="_blank" rel="external">http://blog.csdn.net/lengshengren/article/details/12616217</a></p>
<p><a href="http://stackoverflow.com/questions/10150231/how-to-detect-when-uinavigationcontroller-animation-has-finished" target="_blank" rel="external">http://stackoverflow.com/questions/10150231/how-to-detect-when-uinavigationcontroller-animation-has-finished</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/02/19/iOS7-nested-push-animation-can-result-in-corrupted/" data-id="cl34e5n5k000lotoz3ja2132j" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-消息传递过程解析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/08/iOS-消息传递过程解析/" class="article-date">
  <time datetime="2013-12-08T12:15:30.000Z" itemprop="datePublished">2013-12-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/08/iOS-消息传递过程解析/">iOS 消息传递过程解析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在iOS中调用一个方法，其实是调用一个方法实现的函数指针并传给他对象实例指针，一个Selector，还有函数用到的参数。在Objective-C 中，每一个方法调用其实都是转换成了调用objc_msgSend方法。</p>
<p><code>objc_msgSend</code>的调用过程如下：</p>
<p>0）首先检查消息接受对象是否为nil. 如果消息接受对象为nil，则触发nil-handler. 默认nil-handler是什么都不做的。</p>
<p>1）在垃圾回收环境中（Mac OS X）中，检查是否调用了（retain, release, autorelease, retainCount), 如果是，就返回self. 所以，这就意味着在垃圾回收机制中，retainCount 返回self。这时调用retainCount就会产生无限循环。</p>
<p>2）检查class的缓存中是否有该方法的实现，如果有，调用。</p>
<p>3）在类方法中是否有该方法，如果有就调用类方法的实现。</p>
<p>4）查看父类中是否有该方法实现，如果没有再查找父类的父类中有没有实现。如果找到了，调用。</p>
<p>5）调用<code>resolveInstanceMethod:</code>(或者resolveClassMethod:). 如果返回YES， 则调用。 该对象会有该方法的实现，因为它会调用class_addMethod.</p>
<p>6) 调用<code>forwardingTargetForSelector:</code>. 如果返回non-nil， 则对返回对象发消息。此处不会返回self，否则会进入无限循环。</p>
<p>7）调用<code>methodSignatureForSelector:</code>, 如果返回non-nil, 创建一个NSInvocation 并且将这个NSInvocation传递给forwardInvocation:.</p>
<p>8) 调用<code>doesNotRecognizeSelector:</code>. 默认实现就是抛一个异常。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/12/08/iOS-消息传递过程解析/" data-id="cl34e5n5m000potoz2su2i0er" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-KVO实现方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/11/27/iOS-KVO实现方式/" class="article-date">
  <time datetime="2013-11-27T09:13:57.000Z" itemprop="datePublished">2013-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/27/iOS-KVO实现方式/">iOS KVO实现方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>KVO 也许是iOS中“最神奇”的部分了，因为你不需要在被观察对象中添加任何代码，就可以实现对被观察对象属性改变的通知。KVO究竟是怎么实现的？</p>
<p>KVO是通过Objective－C的runtime来实现的。当你第一次要对一个对象进行观察时，runtime会为你创建一个被观察对象class的subclass。在这个新创建的subclass中，KVO会复写所要观察属性的setter方法，然后转换被观察对象的isa指针，指向新创建的subclass，所以，你想要观察的对象，变成了KVO在runtime时创建的subclass。因为Apple不想让这种机制暴露，所以还会复写要观察对象的class方法，所以，当你调用class来判断该对象的class时，还会显示原对象的class类型，而不是subclass的类型。</p>
<p>继续探究</p>
<pre><code class="Objective-C">// gcc -o kvoexplorer -framework Foundation kvoexplorer.m&#10;&#10;#import &#60;Foundation/Foundation.h&#62;&#10;#import &#60;objc/runtime.h&#62;&#10;&#10;&#10;@interface TestClass : NSObject&#10;{&#10;    int x;&#10;    int y;&#10;    int z;&#10;}&#10;@property int x;&#10;@property int y;&#10;@property int z;&#10;@end&#10;@implementation TestClass&#10;@synthesize x, y, z;&#10;@end&#10;&#10;static NSArray *ClassMethodNames(Class c)&#10;{&#10;    NSMutableArray *array = [NSMutableArray array];&#10;&#10;    unsigned int methodCount = 0;&#10;    Method *methodList = class_copyMethodList(c, &#38;methodCount);&#10;    unsigned int i;&#10;    for(i = 0; i &#60; methodCount; i++)&#10;        [array addObject: NSStringFromSelector(method_getName(methodList[i]))];&#10;    free(methodList);&#10;&#10;    return array;&#10;}&#10;&#10;static void PrintDescription(NSString *name, id obj)&#10;{&#10;    NSString *str = [NSString stringWithFormat:&#10;        @&#34;%@: %@\n\tNSObject class %s\n\tlibobjc class %s\n\timplements methods &#60;%@&#62;&#34;,&#10;        name,&#10;        obj,&#10;        class_getName([obj class]),&#10;        class_getName(obj-&#62;isa),&#10;        [ClassMethodNames(obj-&#62;isa) componentsJoinedByString:@&#34;, &#34;]];&#10;    printf(&#34;%s\n&#34;, [str UTF8String]);&#10;}&#10;&#10;int main(int argc, char **argv)&#10;{&#10;    [NSAutoreleasePool new];&#10;&#10;    TestClass *x = [[TestClass alloc] init];&#10;    TestClass *y = [[TestClass alloc] init];&#10;    TestClass *xy = [[TestClass alloc] init];&#10;    TestClass *control = [[TestClass alloc] init];&#10;&#10;    [x addObserver:x forKeyPath:@&#34;x&#34; options:0 context:NULL];&#10;    [xy addObserver:xy forKeyPath:@&#34;x&#34; options:0 context:NULL];&#10;    [y addObserver:y forKeyPath:@&#34;y&#34; options:0 context:NULL];&#10;    [xy addObserver:xy forKeyPath:@&#34;y&#34; options:0 context:NULL];&#10;&#10;    PrintDescription(@&#34;control&#34;, control);&#10;    PrintDescription(@&#34;x&#34;, x);&#10;    PrintDescription(@&#34;y&#34;, y);&#10;    PrintDescription(@&#34;xy&#34;, xy);&#10;&#10;    printf(&#34;Using NSObject methods, normal setX: is %p, overridden setX: is %p\n&#34;,&#10;          [control methodForSelector:@selector(setX:)],&#10;          [x methodForSelector:@selector(setX:)]);&#10;    printf(&#34;Using libobjc functions, normal setX: is %p, overridden setX: is %p\n&#34;,&#10;          method_getImplementation(class_getInstanceMethod(object_getClass(control),&#10;                                   @selector(setX:))),&#10;          method_getImplementation(class_getInstanceMethod(object_getClass(x),&#10;                                   @selector(setX:))));&#10;&#10;    return 0;&#10;}
</code></pre>
<p>首先，定义一个TestClass，有3个属性。<br>然后定义一些工具函数。ClassMethodNames 通过Objective－C 的runtime函数，来返回当前class实现的方法名。</p>
<p>代码执行结果</p>
<pre><code><span class="attribute">control</span>: <span class="string">&lt;TestClass: 0x104b20&gt; NSObject class TestClass libobjc class TestClass implements methods &lt;setX:, x, setY:, y, setZ:, z&gt;</span>

<span class="oxygene">
x: &lt;TestClass: <span class="number">0</span>x103280&gt; NSObject <span class="keyword">class</span> TestClass libobjc <span class="keyword">class</span> NSKVONotifying_TestClass <span class="keyword">implements</span> methods &lt;setY:, setX:, <span class="keyword">class</span>, dealloc, _isKVOA&gt;

y: &lt;TestClass: <span class="number">0</span>x104b00&gt; NSObject <span class="keyword">class</span> TestClass libobjc <span class="keyword">class</span> NSKVONotifying_TestClass <span class="keyword">implements</span> methods &lt;setY:, setX:, <span class="keyword">class</span>, dealloc, _isKVOA&gt;

xy: &lt;TestClass: <span class="number">0</span>x104b10&gt; NSObject <span class="keyword">class</span> TestClass libobjc <span class="keyword">class</span> NSKVONotifying_TestClass <span class="keyword">implements</span> methods &lt;setY:, setX:, <span class="keyword">class</span>, dealloc, _isKVOA&gt;

<span class="keyword">Using</span> NSObject methods, normal setX: <span class="keyword">is</span> <span class="number">0</span>x195e, overridden setX: <span class="keyword">is</span> <span class="number">0</span>x195e

<span class="keyword">Using</span> libobjc functions, normal setX: <span class="keyword">is</span> <span class="number">0</span>x195e, overridden setX: <span class="keyword">is</span> <span class="number">0</span>x96a1a550</span>
</code></pre><p>可以看出，<br>0)TestClass 在runtime时变成了NSKVONotifying_TestClass</p>
<p>1)虽然x，y只观察了一个属性，但是NSKVONotifying_TestClass却实现了setY, setX方法。也就是说，一个类，KVO只会subclass一个KVO类，也就是NSKVONotifying_TestClass类。</p>
<p>2)NSKVONotifying_TestClass 覆写了class方法，来掩盖subclass的存在，还覆写了dealloc方法。除此之外，还有一个新的方法_isKVOA, 是Apple提供的一个私有方法，用于判断一个object是否生成动态subclass。</p>
<p>原文链接：<a href="http://www.mikeash.com/pyblog/friday-qa-2009-01-23.html" target="_blank" rel="external">http://www.mikeash.com/pyblog/friday-qa-2009-01-23.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/11/27/iOS-KVO实现方式/" data-id="cl34e5n5v0011otozkpwa7bft" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLite/">SQLite</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unix/">Unix</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life/">life</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux-archlinux/">linux, archlinux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/phonegap/">phonegap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming/">programming</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swift-source-code/">swift source code</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编辑器配置文件/">编辑器配置文件</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书/">读书</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 16.67px;">C</a> <a href="/tags/SQLite/" style="font-size: 10px;">SQLite</a> <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/Unix/" style="font-size: 10px;">Unix</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/life/" style="font-size: 10px;">life</a> <a href="/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/tags/linux-archlinux/" style="font-size: 10px;">linux, archlinux</a> <a href="/tags/phonegap/" style="font-size: 10px;">phonegap</a> <a href="/tags/programming/" style="font-size: 10px;">programming</a> <a href="/tags/swift-source-code/" style="font-size: 13.33px;">swift source code</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/编辑器配置文件/" style="font-size: 10px;">编辑器配置文件</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">十二月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">八月 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">四月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">三月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">二月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">十二月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">十一月 2013</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">十月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">八月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">六月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">三月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">十二月 2012</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">十一月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">五月 2012</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/05/13/Swift-Source-Code-ContiguousArray/">Swift Source Code: ContiguousArray</a>
          </li>
        
          <li>
            <a href="/2022/05/11/Swift-Source-Code-Collection/">Swift Source Code: Collection</a>
          </li>
        
          <li>
            <a href="/2022/05/04/Swift-Source-Code-Sequence/">Swift Source Code: Sequence</a>
          </li>
        
          <li>
            <a href="/2021/03/29/Reading-Note-of-Book-Deep-Work/">Reading Note of Book: Deep Work</a>
          </li>
        
          <li>
            <a href="/2021/01/31/又开始写博客了/">又开始写博客了</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Anyuan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">home</a>
  
    <a href="/archives" class="mobile-nav-link">archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>