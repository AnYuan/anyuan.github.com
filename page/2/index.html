<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Anyuan&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="记录点滴">
<meta property="og:type" content="website">
<meta property="og:title" content="Anyuan's blog">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Anyuan's blog">
<meta property="og:description" content="记录点滴">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Anyuan's blog">
<meta name="twitter:description" content="记录点滴">
  
    <link rel="alternative" href="/atom.xml" title="Anyuan&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  

</head>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Anyuan&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">home</a>
        
          <a class="main-nav-link" href="/archives">archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Protocol-Extensions" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/02/Protocol-Extensions/" class="article-date">
  <time datetime="2015-10-02T08:30:37.000Z" itemprop="datePublished">2015-10-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/02/Protocol-Extensions/">Protocol Extensions</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>资源推荐：</p>
<ul>
<li><a href="https://developer.apple.com/videos/wwdc/2015/?id=408" target="_blank" rel="external">Protocol-Oriented Programming in Swift</a>: WWDC 2015 session</li>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2015-06-19-the-best-of-whats-new-in-swift.html" target="_blank" rel="external">The Best of What’s New in Swift</a></li>
<li><a href="http://matthewpalmer.net/blog/2015/08/30/protocol-oriented-programming-in-the-real-world/" target="_blank" rel="external">Protocol Oriented Programming in the Real World</a></li>
<li><a href="https://github.com/matthewpalmer/Locksmith" target="_blank" rel="external">Locksmith</a> : A powerful, protocol-oriented library for working with the keychain in Swift.</li>
<li><a href="https://github.com/FlexMonkey/Blurable" target="_blank" rel="external">Blurable</a> :  Apply a Gaussian Blur to any UIView with Swift Protocol Extensions.</li>
</ul>
<p>此文为 <a href="https://www.mikeash.com/pyblog/friday-qa-2015-06-19-the-best-of-whats-new-in-swift.html" target="_blank" rel="external">The Best of What’s New in Swift</a> 有关Protocol Extensions的翻译。</p>
<h3 id="Protocol_Extensions">Protocol Extensions</h3><p>在Swift 2.0 之前， Objective-C和Swift，在protocols中只能包含方法声明。 protocols只包含接口定义即一堆等待遵守类型去实现的方法。 在Swift 2中使用 protocol extensions, protocols可以既包含声明，也可以包含实现。</p>
<p>经常，会有很多功能性方法适用于一类对象。 如， 所有的集合类型都可以有将一个集合内对象经过映射（map），而创建一个映射后的集合对象。 在Swift 2之前， 有两种方式可以达到这种能力。</p>
<pre><code><span class="bullet">* </span>在protocol中声明方法并要求对应遵循接口的对象实现自己的方法
<span class="bullet">* </span>全局函数
</code></pre><p>Cocoa基本上采用的是第一种解决方案。 虽然这些方法可能太适合成为任何protocol的一部分， 但是Cocoa的集合对象都有一个enumerateObjectsUsingBlock:方法，每个集合类型有各自的实现。</p>
<p>Swift 2之前，采用的是第二种解决方案。 想 map 这种全局函数，操作于 CollectionType . 这种方式很好的共享了函数实现， 但是语法奇怪并且不能针对特定类型重写实现方法。</p>
<p>有了 protocol extensions , 我们可以有了更牛X的第三种方式。  map  可以实现在 CollectionType 的一个扩展（extension）中。 所有遵循 CollectionType  的类型，就自动获得了一个 map 实现。</p>
<p>一下为一个简单的 map 函数实现：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CollectionType</span> </span>&#123;</span><br><span class="line">        <span class="func"><span class="keyword">func</span> <span class="title">myMap</span><span class="generics">&lt;U&gt;</span><span class="params">(f: <span class="keyword">Self</span>.Generator.Element -&gt; U)</span></span> -&gt; [<span class="type">U</span>] &#123;</span><br><span class="line">            <span class="keyword">var</span> result: [<span class="type">U</span>] = []</span><br><span class="line">            <span class="keyword">for</span> elt <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">                result.append(f(elt))</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].myMap(&#123; $<span class="number">0</span> * <span class="number">2</span> &#125;)</span><br><span class="line">    <span class="comment">// This produces [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>
<p>之前只可以作为 Array 的扩展，然后只可以在 Array 中使用。 有了一个接口的扩展， 上面的实现也可以在 Set 和 ArraySlice 和其他遵循 CollectionType  接口的类型中获得。</p>
<p>另一个很有意思的Swift protocol extensions特性是可以对类型做出限制。 举个栗子， 如果你想实现一个 max 属性。 但是 max 并不适用于所有集合类型， 只有那些有序集合才使用这个属性。 没问题！ 只要给扩展加一个限制，要求其实现类型必须遵守 Comparable  协议：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">CollectionType</span> <span class="title">where</span> <span class="title">Self</span>.<span class="title">Generator</span>.<span class="title">Element</span>: <span class="title">Comparable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">max</span>: <span class="type">Self</span>.<span class="type">Generator</span>.<span class="type">Element</span> &#123;</span><br><span class="line">            <span class="keyword">var</span> best = <span class="keyword">self</span>[<span class="keyword">self</span>.startIndex]</span><br><span class="line">            <span class="keyword">for</span> elt <span class="keyword">in</span> <span class="keyword">self</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> elt &gt; best &#123;</span><br><span class="line">                    best = elt</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> best</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Set</span>([<span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]).<span class="built_in">max</span></span><br><span class="line">    <span class="comment">// This produces 5</span></span><br><span class="line"></span><br><span class="line">    [<span class="type">NSObject</span>(), <span class="type">NSObject</span>()].<span class="built_in">max</span></span><br><span class="line">    <span class="comment">// This produces an error, as NSObject is not Comparable</span></span><br></pre></td></tr></table></figure>
<p>protocol extensions 有一个会令人迷惑的地方， 虽然很小但是很重要，决定了protocol extension中方法是否需要动态分发(dynamic dispatch)。</p>
<p>一个在protocol extension中声明的方法也许也会在protocol中声明， 或者只存在于extension中。 只存在extension中的方法，不会动态分发（dynamic dispatch）并且也不能被复写。只声明在protocol中的方法是动态分发（dynamic dispatch）的并且可以被复写。talk is cheap, show me the code:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">     <span class="func"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">extension</span> <span class="title">P</span> </span>&#123;</span><br><span class="line">     <span class="func"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">"default implementation of A"</span>)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="func"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">"default implementation of B"</span>)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">S</span>: <span class="title">P</span> </span>&#123;</span><br><span class="line">     <span class="func"><span class="keyword">func</span> <span class="title">a</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">"specialized implementation of A"</span>)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="func"><span class="keyword">func</span> <span class="title">b</span><span class="params">()</span></span> &#123;</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">"specialized implementation of B"</span>)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">let</span> p: <span class="type">P</span> = <span class="type">S</span>()</span><br><span class="line"> p.a()</span><br><span class="line"> p.b()</span><br></pre></td></tr></table></figure>
<p>上面的代码会打印出：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">specialized <span class="keyword">implementation</span> <span class="keyword">of</span> A和<span class="keyword">default</span> <span class="keyword">implementation</span> <span class="keyword">of</span> B.</span><br></pre></td></tr></table></figure></p>
<p>使用protocol extensions还可以让Swift的protocol方法成为“可选”方法，在Swift 2中，我们可以这样实现一个delegate中的可选方法:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">protocol</span> <span class="title">MyClassDelegate</span> </span>&#123;</span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">shouldDoThingOne</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">    <span class="func"><span class="keyword">func</span> <span class="title">shouldDoThingTwo</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">extension</span> <span class="title">MyClassDelegate</span> </span>&#123;</span><br><span class="line">        <span class="func"><span class="keyword">func</span> <span class="title">shouldDoThingOne</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">            <span class="comment">// Thing one is harmless and should almost always be done</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="func"><span class="keyword">func</span> <span class="title">shouldDoThingTwo</span><span class="params">()</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">            <span class="comment">// Thing two is a menace and should not be done without careful consideration</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/10/02/Protocol-Extensions/" data-id="cl4kp32yo0028vjz65k5wf6a9" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Swift/">Swift</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-7-9-新特性总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/13/iOS-7-9-新特性总结/" class="article-date">
  <time datetime="2015-09-13T08:29:53.000Z" itemprop="datePublished">2015-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/13/iOS-7-9-新特性总结/">iOS 7 - 9 新特性总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="iOS_7">iOS 7</h3><ol>
<li><p><a href="https://developer.apple.com/library/ios/documentation/StringsTextFonts/Conceptual/TextAndWebiPhoneOS/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009542" target="_blank" rel="external">Text Kit</a></p>
<p> 文字排版相关</p>
</li>
</ol>
<ol>
<li>多任务<ul>
<li>设置<code>UIBackgroundModes</code>为<code>fetch</code>来进行定期后台下载。</li>
<li>设置<code>UIBackgroundModes</code>为<code>remote-notification</code>, 用远程推送的方式，来让应用在后台进行下载内容。</li>
</ul>
</li>
</ol>
<ol>
<li>NSURLSession 用来替代NSURLConnection，配合多任务后台下载使用。</li>
<li><p>AirDrop<br> 附近设备分享传输文件，不需要网络。</p>
</li>
<li><p>新Framework:</p>
<ul>
<li>GameController.framework - 与游戏硬件通信</li>
<li>SpriteKit.framework - 游戏图形渲染和动画</li>
<li>Multipeer connectivity framework - 点对点网络</li>
<li>JavaScriptCore.framework - JavaScript对象的oc封装</li>
<li>MediaAccessibility.framework</li>
<li>SafariServices.framework - 用程序添加URL到用户Safari的阅读列表等</li>
</ul>
</li>
</ol>
<h3 id="iOS_8">iOS 8</h3><ol>
<li><p>Swift 1.0</p>
</li>
<li><p><a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214" target="_blank" rel="external">App Extension</a></p>
<ul>
<li>Share， 在系统提供的分享选项中添加自己</li>
<li>Action, 对于选中内容可以执行一个action</li>
<li>Today， 通知中心的widget</li>
<li>Photo editinig.</li>
<li>Storage provider. 与其他应用共享文件存储位置</li>
<li>自定义键盘</li>
</ul>
</li>
<li><p><a href="https://developer.apple.com/library/ios/samplecode/KeychainTouchID/Introduction/Intro.html#//apple_ref/doc/uid/TP40014530" target="_blank" rel="external">Touch ID</a></p>
</li>
<li><p>Photos Framework</p>
</li>
<li>AV Audio Engine: Core Audio 更上层的封装。</li>
<li>HealthKit Framework</li>
<li>HomeKit Framework</li>
<li><a href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/Handoff/HandoffFundamentals/HandoffFundamentals.html#//apple_ref/doc/uid/TP40014338" target="_blank" rel="external">Handoff</a></li>
<li>Size class</li>
<li>Metal - 替代OpenGL ES</li>
</ol>
<h3 id="iOS_9">iOS 9</h3><ol>
<li>Swift 2.0: 错误处理，Availability, Protocol extensions等</li>
<li>iPad 多任务</li>
<li>watchOS2</li>
<li>UI Test</li>
<li>App Thinning</li>
<li>Search API可以搜索App内容</li>
<li>新系统字体San francisco</li>
<li>Safari View Controller</li>
<li>Contacts Framework</li>
<li>3D Touch</li>
<li>Live Photo</li>
</ol>
<p>参考资料：<br>1.<a href="https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS7.html" target="_blank" rel="external">https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS7.html</a></p>
<p>2.<a href="https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS8.html#//apple_ref/doc/uid/TP40014205-SW1" target="_blank" rel="external">https://developer.apple.com/library/ios/releasenotes/General/WhatsNewIniOS/Articles/iOS8.html#//apple_ref/doc/uid/TP40014205-SW1</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/09/13/iOS-7-9-新特性总结/" data-id="cl4kp32yd001ivjz6t5s16te6" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-SQLite-WAL-调研总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/08/SQLite-WAL-调研总结/" class="article-date">
  <time datetime="2015-08-08T08:28:53.000Z" itemprop="datePublished">2015-08-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/08/SQLite-WAL-调研总结/">SQLite WAL 调研总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li>iOS 系统从iOS 7版本自带的SQLite数据库<strong>默认</strong>为开启WAL模式，即<code>journal_mode=WAL</code></li>
<li>iOS 版本4.3 以上系统自带SQLite版本为3.7.0以上（SQLite 3.7.0开始支持WAL）</li>
<li>在创建数据库连接时，执行<br><code>[conn executeUpdate:[NSString stringWithFormat:@”PRAGMA journal_mode=WAL”]];<br></code>即可</li>
<li>使用注意，在开启数据库时，不能只读打开。</li>
<li>低版本的SQLite不能读取高版本的SQLite生成的WAL文件，但是数据库文件是通用的。这种情况在用户进行iOS降级时可能会出现，可以把模式改成delete，再改回WAL来修复。</li>
<li>iOS 版本的SQLite是线程安全的（db 连接不要多线程共享）。<a href="http://www.sqlite.org/cvstrac/wiki?p=MultiThreading" target="_blank" rel="external">详情</a></li>
</ul>
<h3 id="WAL_工作原理：">WAL 工作原理：</h3><p>开启WAL模式后， 会有3个文件:</p>
<p>{<1>}<img src="/Users/mac/Downloads/wal.png" alt="database"></1></p>
<p>.db 为数据库文件</p><br><p>-shm 为每个数据库文件的共享内存文件</p><br><p>-wal 对数据库的修改操作于此文件</p>

<p>修改并不直接写入到数据库文件中，而是写入到另外一个称为WAL的文件中；如果事务失败，WAL中的记录会被忽略，撤销修改；如果事务成功，它将在随后的某个时间被写回到数据库文件中，提交修改。</p>
<p>同步WAL文件和数据库文件的行为被称为checkpoint（检查点），它由SQLite自动执行，默认是在WAL文件积累到1000页修改的时候；当然，在适当的时候，也可以手动执行checkpoint，SQLite提供了相关的接口。执行checkpoint之后，WAL文件会被清空。</p>
<p>在读的时候，SQLite将在WAL文件中搜索，找到最后一个写入点（end mark），记住它，并忽略在此之后的写入点（<strong>这保证了读写和读读可以并行执行</strong>）；随后，它确定所要读的数据所在页是否在WAL文件中，如果在，则读WAL文件中的数据，如果不在，则直接读数据库文件中的数据。为了避免每次读操作都遍历整个WAL文件去查找，SQLite使用了一种叫做wal-index的数据结构（保存于-shm）用于提高查找效率同时减少磁盘I/O。</p>
<p>在写的时候，SQLite将之写入到WAL文件尾即可，读写互不影响，所以渡河写可以同时执行。因为只有一个WAL文件，所以必须保证一次只执行一次写操作，<strong>因此写操作之间不能并行执行</strong>。</p>
<p>checkpoint的时候，将WAL中的数据同步回数据库中。checkpoint操作可以与读操作并行，但，如果有读操作正在读checkpoint要更新的数据库中的数据时，checkpoint操作会停止，直到读操作完成。</p>
<p>WAL在实现的过程中，使用了共享内存技术，因此，所有的读写进程必须在同一个机器上，否则，无法保证数据一致性。</p>
<h3 id="WAL相关使用配置:">WAL相关使用配置:</h3><p>启动： <code>PRAGMA journal_mode=WAL;</code></p>
<h4 id="自动checkpoint操作：">自动checkpoint操作：</h4><p>默认情况下，SQLite 自动触发checkpoint操作</p>
<ul>
<li>当一个COMMIT时，WAL文件的page数超过1000（可配置）</li>
<li>database连接关闭时。</li>
</ul>
<h4 id="手动触发checkpoint操作：详情">手动触发checkpoint操作：<a href="https://www.SQLite.org/pragma.html#pragma_wal_checkpoint" target="_blank" rel="external">详情</a></h4><ul>
<li>PRAGMA wal_autocheckpoint;</li>
<li>PRAGMA wal_autocheckpoint=N;</li>
<li>SQLite3_wal_checkpoint()</li>
</ul>
<p><a href="https://www.sqlite.org/wal.html" target="_blank" rel="external">参考资料</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/08/08/SQLite-WAL-调研总结/" data-id="cl4kp32yk0022vjz6ra89q6cy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/SQLite/">SQLite</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-NSAutoreleasePool-实现原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/10/NSAutoreleasePool-实现原理/" class="article-date">
  <time datetime="2014-12-10T08:16:30.000Z" itemprop="datePublished">2014-12-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/10/NSAutoreleasePool-实现原理/">NSAutoreleasePool 实现原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="概述">概述</h3><p>autorelease 是NSObject的一个类方法，它是通过调用<code>[NSAutoreleasePool addObject:self]</code> 来把一个对象添加到自动释放池中的，因为这是一个类方法，所以有必要知道是对哪个对象进行autorelease调用。</p>
<p>NSAutoreleasePool 实例是保存在每一个线程的stack中。当一个新pool创建，它就会进栈。当一个stack被销毁的时候，它就出栈。 使用NSAutoreleasePool类方法时，需要从当前线程中获取stack最上面的pool对象，来获取当前pool。</p>
<p>当找到正确的pool后，调用addObject: 实例方法来将对象添加到pool中。当对象被添加到pool中，其实他是添加到pool中的一个可变数组中去。</p>
<p>当pool被销毁时，pool会遍历可变数组中的所有对象，并发送 release 方法给每一个对象。还有一点额外说明，如果一个pool被销毁，并且这个pool不是stack最上端的，这个pool还会销毁该pool之上的所有pool。</p>
<h3 id="总结">总结</h3><p>没有方法知道一个对象是否已经被自动释放了。<br>如果对象被autorelease 两次，这个对象就会被两次添加到pool中，当pool被销毁，该对象就会被release两次。<br>自动释放池的对象是当当前自动释放池被释放时被释放。pool是当它的代码显性的销毁它时而被销毁。<br>如果在一个线程上autorelease一个对象，并将它传给另一个线程，不会有特殊处理。当第一个线程池被销毁的时候，该对象也会被release， 不管该对象在新线程发生了什么。如果你需要继续保留这个对象，就需要在传递之前retain这个对象。</p>
<p>原文链接：<a href="http://www.mikeash.com/pyblog/friday-qa-2911-09-02-lets-build-nsautoreleasepool.html" target="_blank" rel="external">http://www.mikeash.com/pyblog/friday-qa-2911-09-02-lets-build-nsautoreleasepool.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/12/10/NSAutoreleasePool-实现原理/" data-id="cl4kp32yr002fvjz6flvoz31a" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Best-Practices-for-Handling-Multitouch-Events" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/12/01/Best-Practices-for-Handling-Multitouch-Events/" class="article-date">
  <time datetime="2014-12-01T08:27:32.000Z" itemprop="datePublished">2014-12-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/12/01/Best-Practices-for-Handling-Multitouch-Events/">Best Practices for Handling Multitouch Events</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ul>
<li><p>Always implement the event cancelation methods.</p>
  <p>In your implementation, restore the state of a view to what it was before the current multitouch sequence. If you don’t, your view could be left in an inconsistent state, or in some cases, another view could receive the cancelation message.</p>
</li>
<li><p>If you handle events in a subclass of UIView, UIViewController, or UIResponder:</p>
<ul>
<li>Implement all of the event handling methods, even if your implementations of those methods do nothing.</li>
<li>Do not call the superclass implementation of the methods.</li>
</ul>
<p></p></li>
<li><p>If you handle events in a subclass of any other UIKit responder class:</p>
<ul>
<li>You do not have to implement all of the event handling methods.</li>
<li>In the methods you do implement, be sure to call the superclass implementation. For example, <code>[super touchesBegan:touches withEvent:event]</code>.</li>
</ul>
<p></p>
</li>
<li><p>Do not forward events to other responder objects of the UIKit Framework.</p>
<p>Instead, forward events to instances of your own subclasses of UIView. Additionally, make sure these responder objects are aware that event forwarding is taking place and tat they can receive touches that are not bound to them.</p>
</li>
<li><p>Do not explicitly send events up the responder chain through the nextResponder method; instead, invoke the superclass implementation and let UIKit handle responder-chain traversal.</p>
</li>
<li><p>Do not use round-to-integer code in your touch handling because you lose precision.</p>
<p>iOS reports touches in a 320x480 coordinate space to maintain source compatiblity. However, on high-resolution devices, the resolution is actually twice as high in each dimension(640x960), which means that touches can land on half-point boundaries on high-resolution devices. On older devices, touches land only on full-point boundaries.</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/12/01/Best-Practices-for-Handling-Multitouch-Events/" data-id="cl4kp32wb0000vjz67imrjo2w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-企业证书签名包ipa无线安装服务器搭建注意事项" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/26/iOS-企业证书签名包ipa无线安装服务器搭建注意事项/" class="article-date">
  <time datetime="2014-08-26T08:26:34.000Z" itemprop="datePublished">2014-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/26/iOS-企业证书签名包ipa无线安装服务器搭建注意事项/">iOS 企业证书签名包ipa无线安装服务器搭建注意事项</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>因为iOS 7.1以后要求链接地址为https(itms-services://?action=download-manifest&amp;url=<a href="https://10.208.99.199/ota/ios/plist/8239)，所以apache服务器要开启https，具体步骤参见：http://www.cnblogs.com/y500/p/3596473.html" target="_blank" rel="external">https://10.208.99.199/ota/ios/plist/8239)，所以apache服务器要开启https，具体步骤参见：http://www.cnblogs.com/y500/p/3596473.html</a></li>
</ol>
<p>在以上步骤需要注意的是，生成SSL证书时，输入的common name要以服务器地址名称一致，如10.208.99.199或者域名，或者</p>
<pre><code>10.<span class="keyword">*</span>.<span class="keyword">*</span>.<span class="keyword">*</span>
</code></pre><p> 通配符形式。</p>
<ol>
<li><p>apache配置文件httpd.conf, httpd-ssl.conf, httpd-vhost.conf三个文件中的ServerName 都要配成与证书适配的名称，如10.208.99.199， 此处一定要保持一致。</p>
</li>
<li><p>在apache httpd.conf配置文件中添加</p>
<pre><code><span class="keyword">AddType </span>application/octet-<span class="keyword">stream </span>ipa
</code></pre></li>
</ol>
<p>, 是为Mac OS X上的配置，其他请上网查阅一下。</p>
<ol>
<li><p>启动apache服务器</p>
<pre><code>sudo apachectl -<span class="keyword">D</span> SSL -k restart
</code></pre></li>
</ol>
<p>通过以上配置，应该是可以搭建无线安装ipa的服务器了。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/26/iOS-企业证书签名包ipa无线安装服务器搭建注意事项/" data-id="cl4kp32xz000wvjz6ljvg6yp1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-Web-py网站迁移Mac-OS-X" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/23/Linux-Web-py网站迁移Mac-OS-X/" class="article-date">
  <time datetime="2014-08-23T08:25:35.000Z" itemprop="datePublished">2014-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/23/Linux-Web-py网站迁移Mac-OS-X/">Linux Web.py网站迁移Mac OS X</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>数据库导出</p>
<pre><code>mysqldump --opt -u name -<span class="tag">p</span> dbname &gt; backupfile.sql
</code></pre></li>
<li><p>在Mac OS X上安装web.py环境<br>0）install web.py</p>
<pre><code>sudo pip <span class="keyword">install</span> web.py
</code></pre></li>
</ol>
<p>1) 安装mod_wsgi<br>下载mod_wsgi</p>
<p><a href="http://code.google.com/p/modwsgi/wiki/DownloadTheSoftware?tm=2" target="_blank" rel="external">http://code.google.com/p/modwsgi/wiki/DownloadTheSoftware?tm=2</a></p>
<p>解压，</p>
<pre><code>./configure

<span class="built_in">make</span>

sudo <span class="built_in">make</span> install
</code></pre><p>2) 配置apache httpd.conf</p>
<pre><code>#<span class="operator"><span class="keyword">Load</span> mod_wsgi <span class="keyword">module</span>:
LoadModule wsgi_module libexec/apache2/mod_wsgi.so

WSGIScriptAlias /ota /<span class="keyword">Users</span>/iosteam/ota_all/website.py/

AddType <span class="built_in">text</span>/html .py

<span class="keyword">Alias</span> /ota/<span class="keyword">static</span> <span class="string">"/Users/iosteam/ota_all/static"</span>

&lt;<span class="keyword">Directory</span> <span class="string">"/Users/iosteam/ota_all"</span>&gt;

  <span class="keyword">Order</span> deny,<span class="keyword">allow</span>

  <span class="keyword">Allow</span> <span class="keyword">from</span> all

&lt;/<span class="keyword">Directory</span>&gt;</span>
</code></pre><p>3) 如果仍不能访问，修改对应的webpy启动文件</p>
<pre><code><span class="comment"># for mod_python</span>

app = web.<span class="type">application</span>(urls, globals())

<span class="type">application</span> = app.wsgifunc()
</code></pre><ol>
<li><p>导入数据库数据</p>
<pre><code>mysql -u root -<span class="tag">p</span> &lt; database.sql
</code></pre></li>
<li><p>安装python连接数据库包</p>
<pre><code>sudo pip search MySQL_python
sudo pip <span class="keyword">install</span> MySQL_python
</code></pre></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/23/Linux-Web-py网站迁移Mac-OS-X/" data-id="cl4kp32yt002jvjz63bzl1p32" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux-服务器高I-O-等待延迟问题查找" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/08/17/Linux-服务器高I-O-等待延迟问题查找/" class="article-date">
  <time datetime="2014-08-17T08:24:51.000Z" itemprop="datePublished">2014-08-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/08/17/Linux-服务器高I-O-等待延迟问题查找/">Linux 服务器高I/O 等待延迟问题查找</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li>首先是top查看一下系统状况</li>
</ol>
<p>发现两个参数异常，一是平均负载高，一是cpu %wa一直在50%以上。</p>
<p>查了一下%wa参数的意义：</p>
<pre><code>wa <span class="comment">-- iowait</span>
 Amount <span class="operator">of</span> <span class="built_in">time</span> <span class="operator">the</span> CPU has been waiting <span class="keyword">for</span> I/O <span class="built_in">to</span> complete.
</code></pre><ol>
<li>查看磁盘读写数据</li>
</ol>
<p>用iostat 查看磁盘状况</p>
<pre><code>$ iostat -x <span class="number">2</span> <span class="number">5</span>
 avg-cpu: %user %nice %system %iowait %steal %idle
  <span class="number">3.66</span> <span class="number">0.00</span> <span class="number">47.64</span> <span class="number">48.69</span> <span class="number">0.00</span> <span class="number">0.00</span>

 Device: rrqm/s wrqm/s r/s w/s rkB/s wkB/s avgrq-sz avgqu-sz await r_await w_await svctm %util
 sda <span class="number">44.50</span> <span class="number">39.27</span> <span class="number">117.28</span> <span class="number">29.32</span> <span class="number">11220.94</span> <span class="number">13126.70</span> <span class="number">332.17</span> <span class="number">65.77</span> <span class="number">462.79</span> <span class="number">9.80</span> <span class="number">2274.71</span> <span class="number">7.60</span> <span class="number">111.41</span>
 dm-<span class="number">0</span> <span class="number">0.00</span> <span class="number">0.00</span> <span class="number">83.25</span> <span class="number">9.95</span> <span class="number">10515.18</span> <span class="number">4295.29</span> <span class="number">317.84</span> <span class="number">57.01</span> <span class="number">648.54</span> <span class="number">16.73</span> <span class="number">5935.79</span> <span class="number">11.48</span> <span class="number">107.02</span>
 dm-<span class="number">1</span> <span class="number">0.00</span> <span class="number">0.00</span> <span class="number">57.07</span> <span class="number">40.84</span> <span class="number">228.27</span> <span class="number">163.35</span> <span class="number">8.00</span> <span class="number">93.84</span> <span class="number">979.61</span> <span class="number">13.94</span> <span class="number">2329.08</span> <span class="number">10.93</span> <span class="number">107.02</span>
</code></pre><p>2.查看进程状态<br>进程状态表</p>
<pre><code>PROCESS STATE CODES
 D uninterruptible sleep (usually IO)
 R <span class="property">running</span> <span class="keyword">or</span> runnable (<span class="function_start"><span class="keyword">on</span></span> <span class="command">run</span> queue)
 S interruptible sleep (waiting <span class="keyword">for</span> an event <span class="keyword">to</span> complete)
 T stopped, either <span class="keyword">by</span> a job control signal <span class="keyword">or</span> because <span class="keyword">it</span> <span class="keyword">is</span> being traced.
 W paging (<span class="keyword">not</span> valid <span class="keyword">since</span> <span class="keyword">the</span> <span class="number">2.6</span>.xx kernel)
 X dead (should never be seen)
 Z defunct (<span class="string">"zombie"</span>) process, terminated <span class="keyword">but</span> <span class="keyword">not</span> reaped <span class="keyword">by</span> <span class="keyword">its</span> parent.
</code></pre><p>查看到进程中状态D（disk sleep）的进程</p>
<pre><code># <span class="keyword">for</span> <span class="keyword">x</span> in `seq <span class="number">1</span> <span class="number">1</span> <span class="number">10</span>`; <span class="keyword">do</span> <span class="keyword">ps</span> -eo state,pid,cmd | <span class="keyword">grep</span> <span class="string">"^D"</span>; <span class="keyword">echo</span> <span class="string">"----"</span>; <span class="keyword">sleep</span> <span class="number">5</span>; done
</code></pre><p>查看到有kjournald这个进程<br>查看这个进程是做什么的？</p>
<p>kjournald是ext3文件系统记录文件系统日志的进程。</p>
<p>查看进程相关状态信息</p>
<pre><code><span class="preprocessor"># cat /proc/<span class="number">487</span>/io</span>
 rchar: <span class="number">48752567</span>
 wchar: <span class="number">549961789</span>
 syscr: <span class="number">5967</span>
 syscw: <span class="number">67138</span>
 read_bytes: <span class="number">49020928</span>
 write_bytes: <span class="number">549961728</span>
 cancelled_write_bytes: <span class="number">0</span>
</code></pre><p>查看都往哪写东西了</p>
<pre><code><span class="preprocessor"># lsof -p <span class="number">487</span></span>
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/08/17/Linux-服务器高I-O-等待延迟问题查找/" data-id="cl4kp32ys002hvjz6nealwn0t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-GCD常用函数总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/04/19/iOS-GCD常用函数总结/" class="article-date">
  <time datetime="2014-04-19T07:58:16.000Z" itemprop="datePublished">2014-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/19/iOS-GCD常用函数总结/">iOS GCD常用函数总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>GCD提供两种Dispatch Queue, 分别为Concurrent Dispatch Queue 和 Serial Dispatch Queue.</p>
<p>Serial Dispatch Queue 使用一个thread。</p>
<p>Concurrent Dispatch Queue 使用多个thread。</p>
<p>获取Dispatch Queue:</p>
<p>0）dispatch_queue_create</p>
<pre><code><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">"name.of.your.queue"</span>,<span class="literal">NULL</span>);
</code></pre><p>第一个参数为queue的名字，第二个参数传NULL表明要创建一个Serial Dispatch Queue, 传入DISPATCH_QUEUE_CONCURRENT 创建一个 Concurrent Dispatch Queue。<br>如果是对数据库表更新或更新文件，最好为每一个表或文件建立一个Serial Dispatch Queue，这样能保证只有一个thread会对数据进行更新。</p>
<p>如果对那些不会引起数据不一致问题的任务，需要放到Concurrent Dispatch Queue执行。</p>
<p>1）从Main Dispatch Queue/Global Dispatch Queue获取</p>
<pre><code><span class="comment">//main queue</span>
<span class="keyword">dispatch_queue_t</span> mainQueue = dispatch_get_main_queue();

<span class="comment">//global queue of high priority</span>
<span class="keyword">dispatch_queue_t</span> globalHigh =         dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH,<span class="number">0</span>);

<span class="comment">//global queue of default priority</span>
<span class="keyword">dispatch_queue_t</span> globalDefault =     dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);

<span class="comment">//global queue of low priority</span>
<span class="keyword">dispatch_queue_t</span> globalLow = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_LOW,<span class="number">0</span>);

<span class="comment">//global queue of background priority</span>
<span class="keyword">dispatch_queue_t</span> globalBackground = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND,<span class="number">0</span>);
</code></pre><p>Main Dispatch Queue -&gt; Serial dispatch queue<br>Global Dispatch Queue -&gt; Concurrent dispatch queue</p>
<p>dispatch_set_target_queue: 主要用来给新建的queue设置优先级</p>
<pre><code>dispatch_queue_t serialQueue = dispatch_queue_create<span class="list">(<span class="string">"name.of.queue"</span>,NULL)</span><span class="comment">;</span>

dispatch_queue_t globalQueue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_BACKGROUND</span>,<span class="number">0</span>)</span><span class="comment">;</span>

dispatch_set_target_queue<span class="list">(<span class="keyword">serialQueue</span>, globalQueue)</span><span class="comment">;</span>
</code></pre><p>需要注意的是，第一个参数是自定义的queue，而不是系统的queue。因为你不能给系统的queue设置权限。通过上面设置，serialQueue 就有了与globalQueue一样的优先级。其实这个函数不仅可以设置queue的优先级，还可以设置queue之间的层级结构。</p>
<p>dispatch_after: 过一段时间执行queue中的task</p>
<pre><code>dispatch_time_t <span class="property">time</span> = dispatch_time(DISPATCH_TIME_NOW, <span class="number">3</span>ull * NSEC_PER_SEC);

dispatch_after(<span class="property">time</span>, dispatch_get_main_queue(),^{
           NSLog(@<span class="string">"after 3 seconds..."</span>);});
</code></pre><p>Dispatch Group</p>
<p>0）dispatch_group_notify</p>
<p>dispatch group 可以在group中的dispatch queue都执行完之后，通过一个dispatch_group_notify通知回调。</p>
<pre><code>dispatch_queue_t queue = dispatch_get_global_queue<span class="list">(<span class="keyword">DISPATCH_QUEUE_PRIORITY_DEFAULT</span>,<span class="number">0</span>)</span><span class="comment">;</span>

dispatch_group_t group = dispatch_group_create<span class="list">()</span><span class="comment">;</span>

dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^{NSLog<span class="list">(@<span class="string">"task1"</span>)</span><span class="comment">;});</span>
dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^{NSLog<span class="list">(@<span class="string">"task2"</span>)</span><span class="comment">;});</span>
dispatch_group_async<span class="list">(<span class="keyword">group</span>, queue, ^{NSLog<span class="list">(@<span class="string">"task3"</span>)</span><span class="comment">;});</span>

dispatch_group_notify<span class="list">(<span class="keyword">group</span>, dispatch_get_main_queue<span class="list">()</span>, ^{NSLog<span class="list">(@<span class="string">"finished..."</span>)</span><span class="comment">;});</span></span></span></span></span>
</code></pre><p>输出总会保证”finished…”会在最后一句输出。</p>
<pre><code><span class="number">1</span>）dispatch_group_wait

dispatch_queue_t <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);

dispatch_group_t <span class="keyword">group</span> = dispatch_group_create();

dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{NSLog(@<span class="string">"task1"</span>);});
dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{NSLog(@<span class="string">"task2"</span>);});
dispatch_group_async(<span class="keyword">group</span>, <span class="built_in">queue</span>, ^{NSLog(@<span class="string">"task3"</span>);});

dispatch_group_wait(<span class="keyword">group</span>, DISPATCH_TIME_FOREVER);
</code></pre><p>dispatch_group_wait提供了一种类似超时的机制，当然如果等待时间设置为DISPATCH_TIME_FOREVER,功能和dispatch_group_notify是一样的。</p>
<p>dispatch_barrier_async</p>
<p>dispatch_barrier_async是一个可以让当前任务等待queue其他任务完成再执行的函数。例如，从数据库读取数据是可以多线程并发读取的，因为这样提高效率。但是，更新数据库数据，就要保证只有一个线程进行更新操作。所以，当更新操作发生的时候，一定要保证读操作和其他更新操作等待。</p>
<pre><code>dispatch_queue_t queue = dispatch_queue_create<span class="list">(<span class="string">"barrier.queue"</span>, DISPATCH_QUEUE_CONCURRENT)</span><span class="comment">;</span>

dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_0)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_1)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_2)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_3)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_4)</span><span class="comment">;</span>

dispatch_barrier_async<span class="list">(<span class="keyword">queue</span>, update_block)</span><span class="comment">;</span>

dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_5)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_6)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_7)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_8)</span><span class="comment">;</span>
dispatch_async<span class="list">(<span class="keyword">queue</span>, read_block_9)</span><span class="comment">;</span>
</code></pre><p>这样就可以保证只有当更新操作结束后，才会进行其他数据库读操作，保证了数据的一致性。</p>
<p>dispatch_apply</p>
<p>dispatch_apply用于给一个block添加到dispatch queue若干次。 “for”循环</p>
<pre><code><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);

dispatch_apply(<span class="number">10</span>, <span class="built_in">queue</span>, ^(<span class="keyword">size_t</span> index) { NSLog(@<span class="string">"%zu"</span>,index);});

NSLog(@<span class="string">"done..."</span>);
</code></pre><p>dispatch_suspend/dispatch_resume</p>
<p>用于暂停和继续执行queue</p>
<p>dispatch semaphore</p>
<p>dispatch semaphore 适合处理比dispatch queue或者dispatch_barrier_async更小颗粒度的操作。</p>
<p>例如，</p>
<pre><code><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);

NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];

<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)
{
dispatch_async(<span class="built_in">queue</span>, ^{
  [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:i]];
});
}
</code></pre><p>如果执行上段代码，因为NSMutableArray不是thread safe的，所以在global queue中对其进行添加对象，会导致程序crash掉。</p>
<p>使用dispatch semaphore我们可以实现多线程对NSMutableArray进行操作</p>
<pre><code><span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT,<span class="number">0</span>);

<span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>);

NSMutableArray *<span class="built_in">array</span> = [[NSMutableArray alloc] init];

<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)
{
dispatch_async(<span class="built_in">queue</span>, ^{

  dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);

  [<span class="built_in">array</span> addObject:[NSNumber numberWithInt:i]];

  dispatch_semaphore_signal(semaphore);
});
}
</code></pre><p>dispatch semaphore 是一个信号量的counter，当counter为0，当前线程停止运行，当大于0，自减1，继续执行。</p>
<p>dispatch_semaphore_create</p>
<pre><code><span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">1</span>);
</code></pre><p>初始化一个counter为1的semaphore.<br>dispatch_semaphore_wait</p>
<pre><code>dispatch_semaphore_wait<span class="list">(<span class="keyword">semaphore</span>, DISPATCH_TIME_FOREVER)</span><span class="comment">;</span>
</code></pre><p>等待counter大于0才运行，第二个参数为等待时间。执行后counter减1.</p>
<p>dispatch_semaphore_signal</p>
<pre><code>dispatch_semaphore_signal<span class="list">(<span class="keyword">semaphore</span>)</span><span class="comment">;</span>
</code></pre><p>给counter加1<br>所以在上面的代码中，就可以保证在wait和signal中的[array addObject:[NSNumber numberWithInt:i]]; 就只有一个thread进行操作，保证了线程安全。</p>
<p>dispatch_onece</p>
<p>保证了dispatch_once中的代码只会被执行一次，常用于单例。</p>
<pre><code>+ (<span class="keyword">id</span>)sharedManager {
<span class="keyword">static</span> MyManager *sharedMyManager = <span class="literal">nil</span>;
<span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;
<span class="built_in">dispatch_once</span>(&amp;onceToken, ^{
    sharedMyManager = [[<span class="keyword">self</span> alloc] init];
});
<span class="keyword">return</span> sharedMyManager;
}
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/04/19/iOS-GCD常用函数总结/" data-id="cl4kp32ya001avjz6saa0fe4t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-Block实现探究" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/04/06/iOS-Block实现探究/" class="article-date">
  <time datetime="2014-04-06T08:22:21.000Z" itemprop="datePublished">2014-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/04/06/iOS-Block实现探究/">iOS Block实现探究</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用clang的rewrite-objc filename 可以将有block的c代码转换成cpp代码。从中可以看到block的实现。</p>
<pre><code><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span>
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
  <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^{
    <span class="built_in">printf</span>(<span class="string">"Block\n"</span>);
  };
  blk();
  <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>使用clang rewrite-objc以后会看到block的实现</p>
<pre><code><span class="keyword">struct</span> __main_block_impl_0 {
 <span class="keyword">struct</span> __block_impl <span class="keyword">impl</span>;
 <span class="keyword">struct</span> __main_block_desc_0* Desc;
  __main_block_impl_0(void *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> flags=<span class="number">0</span>)
{
<span class="keyword">impl</span>.isa = &amp;_NSConcreteStackBlock;
<span class="keyword">impl</span>.Flags = flags;
<span class="keyword">impl</span>.FuncPtr = fp;
Desc = desc;
 }
};
</code></pre><p>可以看到其实block是一个正常的OC类</p>
<p>来看看block是怎样访问外部变量的</p>
<pre><code><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
  <span class="keyword">int</span> dmy = <span class="number">256</span>;
  <span class="keyword">int</span> val = <span class="number">10</span>;
  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"val = %d\n"</span>;
  <span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = ^{
    <span class="built_in">printf</span>(fmt, val);
  };
  <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>转换之后，可以看到</p>
<pre><code><span class="keyword">struct</span> __main_block_impl_0 {
  <span class="keyword">struct</span> __block_impl impl;
  <span class="keyword">struct</span> __main_block_desc_0* Desc;
  <span class="keyword">const</span> <span class="keyword">char</span> *fmt;
  <span class="keyword">int</span> val;
  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">const</span> <span class="keyword">char</span> *_fmt, <span class="keyword">int</span> _val, <span class="keyword">int</span> flags=<span class="number">0</span>) : fmt(_fmt), val(_val) {
impl.isa = &amp;_NSConcreteStackBlock;
impl.Flags = flags;
impl.FuncPtr = fp;
Desc = desc;
  }
};


<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
  <span class="keyword">int</span> dmy = <span class="number">256</span>;
  <span class="keyword">int</span> val = <span class="number">10</span>;
  <span class="keyword">const</span> <span class="keyword">char</span> *fmt = <span class="string">"val = %d\n"</span>;
  <span class="keyword">void</span> (*blk)(<span class="keyword">void</span>) = (<span class="keyword">void</span> (*)())&amp;__main_block_impl_0((<span class="keyword">void</span> *)__main_block_func_0, &amp;__main_block_desc_0_DATA, fmt, val);
  <span class="keyword">return</span> <span class="number">0</span>;
}
</code></pre><p>block的变量会被复制进block中</p>
<p>如果当block要改变传入的变量值怎么办？首先看一下全局变量和本地静态变量</p>
<pre><code><span class="keyword">int</span> global_val = <span class="number">1</span>;
<span class="keyword">static</span> <span class="keyword">int</span> static_global_val = <span class="number">2</span>;
<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>
</span>{
  <span class="keyword">static</span> <span class="keyword">int</span> static_val = <span class="number">3</span>;
  <span class="keyword">void</span>(^blk)(<span class="keyword">void</span>) = ^{
  global_val *= <span class="number">1</span>;
   static_global_val *= <span class="number">2</span>;
  static_val *= <span class="number">3</span>;
  };
  blk();
  <span class="keyword">return</span> <span class="number">0</span>;
}



<span class="keyword">struct</span> __main_block_impl_0 {
  <span class="keyword">struct</span> __block_impl impl;
  <span class="keyword">struct</span> __main_block_desc_0* Desc;
  <span class="keyword">int</span> *static_val;
  __main_block_impl_0(<span class="keyword">void</span> *fp, <span class="keyword">struct</span> __main_block_desc_0 *desc, <span class="keyword">int</span> *_static_val, <span class="keyword">int</span> flags=<span class="number">0</span>) : static_val(_static_val) {
impl.isa = &amp;_NSConcreteStackBlock;
impl.Flags = flags;
impl.FuncPtr = fp;
Desc = desc;
  }
};
<span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) {
  <span class="keyword">int</span> *static_val = __cself-&gt;static_val; <span class="comment">// bound by copy</span>

global_val *= <span class="number">1</span>;
static_global_val *= <span class="number">2</span>;
(*static_val) *= <span class="number">3</span>;
}
</code></pre><p>由于全局变量是在Data Section中，所以直接可以访问。局部静态变量是通过将其指针传入到block中，block就可以对其值进行修改。</p>
<p>然后看一下__block修饰符变量</p>
<pre><code><span class="type">int</span> main()
{
  __block <span class="type">int</span> val = <span class="number">10</span>;
  <span class="type">void</span> (^blk)(<span class="type">void</span>) = ^{val = <span class="number">1</span>;};
  blk();
  <span class="keyword">return</span> <span class="number">0</span>;
}

struct __main_block_impl_0 {
  struct __block_impl impl;
  struct __main_block_desc_0* <span class="type">Desc</span>;
  __Block_byref_val_0 *val; // by <span class="keyword">ref</span>
  __main_block_impl_0(<span class="type">void</span> *fp, struct __main_block_desc_0 *desc,             __Block_byref_val_0 *_val, <span class="type">int</span> flags=<span class="number">0</span>) : val(_val-&gt;__forwarding) {
impl.isa = &amp;_NSConcreteStackBlock;
impl.<span class="type">Flags</span> = flags;
impl.<span class="type">FuncPtr</span> = fp;
<span class="type">Desc</span> = desc;
  }
};
<span class="keyword">static</span> <span class="type">void</span> __main_block_func_0(struct __main_block_impl_0 *__cself) {
  __Block_byref_val_0 *val = __cself-&gt;val; // bound by <span class="keyword">ref</span>
(val-&gt;__forwarding-&gt;val) = <span class="number">1</span>;}
<span class="keyword">static</span> <span class="type">void</span> __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src)
</code></pre><p><strong>block修饰符的变量，会生成一个</strong>Block_byref_val_0的struct，然后通过访问其<strong>forwarding来访问val值。因为Block有可能是在stack或者heap中，所以用</strong>forwarding来访问。之所以会将__block单独生成一个struct是因为可能该变量会被多个block使用。</p>
<p>Block分三种类型</p>
<p>0) NSConcreteStackBlock    –stack</p>
<p>1) NSConcreteGlobalBlock   –data area</p>
<p>2) NSConcreteMallocBlock   –heap</p>
<p>自动copy block</p>
<p>当开启ARC时，在某些情况编译器会自动copy block，从stack到heap。</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">int</span> （^<span class="keyword">blk_t</span>)(<span class="keyword">int</span>);
<span class="keyword">blk_t</span> func(<span class="keyword">int</span> rate)
{
  <span class="keyword">return</span> ^(<span class="keyword">int</span> count){<span class="keyword">return</span> rate * count;};
}


<span class="keyword">blk_t</span> func(<span class="keyword">int</span> rate)
{
  <span class="keyword">blk_t</span> tmp = &amp;__func_block_impl_0(
__func_block_func_0, &amp;__func_block_desc_0_DATA, rate);

  tmp = objc_retainBlock(tmp);
  <span class="keyword">return</span> objc_autoreleaseReturnValue(tmp);
}
</code></pre><p>有些情况，编译器是无法检测是否应该copy block：</p>
<p>当block作为参数传递到方法或函数中。</p>
<p>但是，如果该方法或函数在内部copy，就不用手动再copy：</p>
<p>0）cocoa framework方法， 有usingBlock</p>
<p>1) GCD API</p>
<pre><code>- (<span class="keyword">id</span>) getBlockArray
{
  <span class="keyword">int</span> val = <span class="number">10</span>;
  <span class="keyword">return</span> [[<span class="built_in">NSArray</span> alloc] initWithObjects:
 [^{<span class="built_in">NSLog</span>(<span class="string">@"blk0:%d"</span>, val);} <span class="keyword">copy</span>],
 [^{<span class="built_in">NSLog</span>(<span class="string">@"blk1:%d"</span>, val);} <span class="keyword">copy</span>], <span class="literal">nil</span>];
}
</code></pre><p>__forwarding</p>
<p>当block从stack copy到 heap中时，block中用到的<strong>block也会copy到heap中，并且copy到heap中的block拥有该</strong>block。</p>
<pre><code>__block int <span class="keyword">val</span> = <span class="number">0</span>;
<span class="keyword">void</span> (^blk)(<span class="keyword">void</span>) = [^{++<span class="keyword">val</span>;} copy];
++<span class="keyword">val</span>;
blk();
NSLog(<span class="string">@"%d"</span>, <span class="keyword">val</span>);
</code></pre><p>在block和外的++val都会变成 ++(val.<strong>forwarding-&gt;val);<br>当block copy到heap中后， stack中的</strong>forwarding会指向heap中的<strong>block, heap中的</strong>forwarding会指向自己的<strong>block值，这样保证了</strong>forwarding指向的是同一个变量值。</p>
<p>Block什么时候会copy到heap中</p>
<p>0）对block调用copy方法。</p>
<p>1）block作为一个函数的返回值。 编译器自动copy</p>
<p>2）赋值给id或block type class 有__strong 修饰符的成员变量。   编译器自动copy</p>
<p>3）usingBlock, GCD API。  在函数内copy</p>
<p>什么时候用该copy block？</p>
<p>0） block是函数返回值</p>
<p>1） block赋值给id或block type class 有__strong 修饰符的成员变量。</p>
<p>2）3）usingBlock, GCD API。  在函数内copy</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/04/06/iOS-Block实现探究/" data-id="cl4kp32yd001gvjz6ew6ralwu" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>

    </footer>
  </div>
  
</article>


  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
    </nav>
  
</section>
        
          <aside id="sidebar">
  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/">C</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQLite/">SQLite</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Unix/">Unix</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/combine/">combine</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/iOS/">iOS</a><span class="tag-list-count">20</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/life/">life</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux-archlinux/">linux, archlinux</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/phonegap/">phonegap</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/programming/">programming</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/reading/">reading</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swift-source-code/">swift source code</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/算法/">算法</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/编辑器配置文件/">编辑器配置文件</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/读书/">读书</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C/" style="font-size: 17.5px;">C</a> <a href="/tags/SQLite/" style="font-size: 10px;">SQLite</a> <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/Unix/" style="font-size: 10px;">Unix</a> <a href="/tags/combine/" style="font-size: 12.5px;">combine</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a> <a href="/tags/life/" style="font-size: 10px;">life</a> <a href="/tags/linux/" style="font-size: 15px;">linux</a> <a href="/tags/linux-archlinux/" style="font-size: 10px;">linux, archlinux</a> <a href="/tags/phonegap/" style="font-size: 10px;">phonegap</a> <a href="/tags/programming/" style="font-size: 10px;">programming</a> <a href="/tags/reading/" style="font-size: 12.5px;">reading</a> <a href="/tags/swift-source-code/" style="font-size: 15px;">swift source code</a> <a href="/tags/算法/" style="font-size: 10px;">算法</a> <a href="/tags/编辑器配置文件/" style="font-size: 10px;">编辑器配置文件</a> <a href="/tags/读书/" style="font-size: 10px;">读书</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">三月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/01/">一月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">十二月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">八月 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">四月 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">三月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">二月 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">十二月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">十一月 2013</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">十月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">八月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">七月 2013</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">六月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">五月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/03/">三月 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/01/">一月 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/12/">十二月 2012</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/11/">十一月 2012</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/05/">五月 2012</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/06/19/悉达多/">悉达多</a>
          </li>
        
          <li>
            <a href="/2022/06/13/信心/">信心</a>
          </li>
        
          <li>
            <a href="/2022/06/04/Combine-Publisher/">Combine: Publisher</a>
          </li>
        
          <li>
            <a href="/2022/05/30/Combine-Introduction/">Combine: Introduction</a>
          </li>
        
          <li>
            <a href="/2022/05/13/Swift-Source-Code-ContiguousArray/">Swift Source Code: ContiguousArray</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 Anyuan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">home</a>
  
    <a href="/archives" class="mobile-nav-link">archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>